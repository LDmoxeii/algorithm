package com.only4.algorithm.leetcode

/**
 * [70. 爬楼梯](https://leetcode.com/problems/climbing-stairs/)
 *
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 *
 * 示例:
 * - 输入: n = 2
 * - 输出: 2
 * - 解释: 有两种方法可以爬到楼顶。
 *   1. 1 阶 + 1 阶
 *   2. 2 阶
 *
 * - 输入: n = 3
 * - 输出: 3
 * - 解释: 有三种方法可以爬到楼顶。
 *   1. 1 阶 + 1 阶 + 1 阶
 *   2. 1 阶 + 2 阶
 *   3. 2 阶 + 1 阶
 *
 * 解题思路:
 * 这是一个经典的动态规划问题，类似于斐波那契数列。
 * 要到达第n阶楼梯，可以从第n-1阶爬1步上来，或者从第n-2阶爬2步上来。
 * 因此，到达第n阶的方法数是到达第n-1阶和到达第n-2阶的方法数之和。
 * 即：dp[n] = dp[n-1] + dp[n-2]
 *
 * 为了优化空间复杂度，我们只需要保存两个变量：前一阶和前两阶的方法数。
 *
 * 时间复杂度: O(n)，需要计算从1到n的每一阶的方法数
 * 空间复杂度: O(1)，只使用了常数级别的额外空间
 *
 * @param n 楼梯的阶数
 * @return 爬到楼顶的不同方法数
 */
fun climbStairs(n: Int): Int {
    if (n <= 2) return n

    // dp[i-2]，表示到达前两阶的方法数
    var prev = 1
    // dp[i-1]，表示到达前一阶的方法数
    var curr = 2

    // 从第3阶开始计算
    for (i in 3..n) {
        // 计算当前阶的方法数
        val sum = prev + curr
        // 更新前两阶的方法数（当前的前一阶变成下一轮的前两阶）
        prev = curr
        // 更新前一阶的方法数（当前阶的方法数变成下一轮的前一阶）
        curr = sum
    }

    // 返回到达第n阶的方法数
    return curr
}
