package com.only4.algorithm.leetcode

/**
 * [198. 打家劫舍](https://leetcode.com/problems/house-robber/)
 *
 * 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋
 * 装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 *
 * 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
 *
 * 示例:
 * - 输入: [1,2,3,1]
 * - 输出: 4
 * - 解释: 偷窃第1间房屋(金额=1)，然后偷窃第3间房屋(金额=3)。偷窃到的最高金额 = 1 + 3 = 4。
 *
 * - 输入: [2,7,9,3,1]
 * - 输出: 12
 * - 解释: 偷窃第1间房屋(金额=2), 偷窃第3间房屋(金额=9)，接着偷窃第5间房屋(金额=1)。
 *   偷窃到的最高金额 = 2 + 9 + 1 = 12。
 *
 * 解题思路:
 * 这是一个典型的动态规划问题。对于每个房屋，我们有两个选择：
 * 1. 偷窃当前房屋：那么就不能偷窃前一个房屋，最大金额为 当前房屋的金额 + 前两个房屋之前的最大金额
 * 2. 不偷窃当前房屋：那么最大金额就是前一个房屋的最大金额
 *
 * 我们可以使用两个变量来保存状态：
 * - prev: 表示偷到前两个房屋为止的最大金额
 * - curr: 表示偷到前一个房屋为止的最大金额
 *
 * 时间复杂度: O(n)，其中n是房屋的数量
 * 空间复杂度: O(1)，只使用了常数级别的额外空间
 *
 * @param nums 代表每个房屋存放金额的非负整数数组
 * @return 不触动警报装置的情况下能够偷窃到的最高金额
 */
fun rob(nums: IntArray): Int {
    // 处理边界情况
    if (nums.size <= 2) return maxOf(nums.getOrElse(0) { 0 }, nums.getOrElse(1) { 0 })

    // prev表示偷到前两个房屋为止的最大金额
    var prev = 0
    // curr表示偷到前一个房屋为止的最大金额
    var curr = 0

    for (money in nums) {
        // 当前房屋的最大金额 = max(偷当前房屋 + 前两个房屋的最大金额, 不偷当前房屋即前一个房屋的最大金额)
        val maxMoney = maxOf(money + prev, curr)
        // 更新状态
        prev = curr
        curr = maxMoney
    }

    return curr
}
