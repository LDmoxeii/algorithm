---
title: 算法解析
create time: 202509131314
tags: [ ]
aliases: [ ]
hierarchy:
status: Undone
preloadIframes: true
---

# 算法解析

## 哈希

### [两数之和](https://leetcode.cn/problems/two-sum/)

**题目描述：**
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]
```

**约束条件：**

- 2 ≤ nums.length ≤ 10^4
- -10^9 ≤ nums[i] ≤ 10^9
- -10^9 ≤ target ≤ 10^9
- 只会存在一个有效答案

#### 解题思路

**核心思想：** 使用哈希表存储已遍历过的数值及其索引，对于当前数值，查找目标值与当前值的差值是否在哈希表中存在。

**算法步骤：**

1. 创建哈希表存储 `数值 -> 索引` 的映射
2. 遍历数组，对于每个元素：
   - 计算目标差值：`complement = target - nums[i]`
   - 检查差值是否在哈希表中
   - 如果存在，返回当前索引和哈希表中的索引
   - 如果不存在，将当前数值和索引存入哈希表

**时间复杂度：** O(n) - 只需遍历一次数组
**空间复杂度：** O(n) - 哈希表最多存储n个元素

#### 代码实现

**Java版本：**

```java
public class TwoSum {
   public int[] twoSum(int[] nums, int target) {
      // 哈希表：数值 -> 索引
      Map<Integer, Integer> numIndexMap = new HashMap<>();

      for (int i = 0; i < nums.length; i++) {
         int currentNum = nums[i];
         int complement = target - currentNum;

         // 检查补数是否已存在
         if (numIndexMap.containsKey(complement)) {
            return new int[]{numIndexMap.get(complement), i};
         }

         // 存储当前数值和索引
         numIndexMap.put(currentNum, i);
      }

      throw new IllegalArgumentException("No two sum solution");
   }
}
```

**Kotlin版本：**

```kotlin
fun twoSum(nums: IntArray, target: Int): IntArray {
   // 哈希表：数值 -> 索引
   val numIndexMap = HashMap<Int, Int>()

   nums.forEachIndexed { index, currentNum ->
      val complement = target - currentNum

      // 检查补数是否已存在，如果存在则返回结果
      numIndexMap[complement]?.let { complementIndex ->
         return intArrayOf(complementIndex, index)
      }

      // 存储当前数值和索引
      numIndexMap[currentNum] = index
   }

   throw IllegalArgumentException("No two sum solution")
}
```

**哈希表解法的优势：**

- 时间复杂度从O(n²)优化到O(n)
- 只需一次遍历，效率更高
- 适用于大规模数据处理

### [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

**题目描述：**
给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。

字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，通常只使用所有原字母一次。

**示例：**

```
输入：strs = ["eat","tea","tan","ate","nat","bat"]
输出：[["bat"],["nat","tan"],["ate","eat","tea"]]
解释：
- "eat", "tea", "ate" 是字母异位词
- "tan", "nat" 是字母异位词
- "bat" 独自一组
```

**约束条件：**

- 1 ≤ strs.length ≤ 10^4
- 0 ≤ strs[i].length ≤ 100
- strs[i] 仅包含小写字母

#### 解题思路

**核心思想：** 字母异位词具有相同的字符组成，只是顺序不同。将每个字符串的字符排序后作为key，相同key的字符串归为一组。

**算法步骤：**

1. 创建哈希表存储 `排序后的字符串 -> 原字符串列表` 的映射
2. 遍历字符串数组，对于每个字符串：
   - 将字符串转换为字符数组并排序
   - 将排序后的字符串作为key
   - 将原字符串添加到对应key的列表中
3. 返回哈希表中所有值的集合

**时间复杂度：** O(n × k log k) - n是字符串数量，k是字符串平均长度，排序需要k log k时间
**空间复杂度：** O(n × k) - 哈希表存储所有字符串

#### 代码实现

**Java版本：**

```java
public class GroupAnagrams {
   public List<List<String>> groupAnagrams(String[] strs) {
      // 哈希表：排序后的字符串 -> 原字符串列表
      Map<String, List<String>> anagramGroups = new HashMap<>();

      for (String str : strs) {
         // 将字符串转换为字符数组并排序
         char[] chars = str.toCharArray();
         Arrays.sort(chars);
         String sortedStr = new String(chars);

         // 将原字符串添加到对应组中
         anagramGroups.computeIfAbsent(sortedStr, k -> new ArrayList<>()).add(str);
      }

      return new ArrayList<>(anagramGroups.values());
   }
}
```

**Kotlin版本：**

```kotlin
fun groupAnagrams(strs: Array<String>): List<List<String>> {
   // 哈希表：排序后的字符串 -> 原字符串列表
   val anagramGroups = HashMap<String, MutableList<String>>()

   strs.forEach { str ->
      // 将字符串转换为字符数组并排序
      val sortedStr = str.toCharArray().sorted().joinToString("")

      // 将原字符串添加到对应组中
      anagramGroups.getOrPut(sortedStr) { mutableListOf() }.add(str)
   }

   return anagramGroups.values.toList()
}
```

**哈希表解法的优势：**

- 通过排序字符确保字母异位词有相同的key
- 一次遍历完成分组，效率高
- 自动处理重复和空字符串的情况

### [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

**题目描述：**
给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

**示例：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**约束条件：**

- 0 ≤ nums.length ≤ 10^5
- -10^9 ≤ nums[i] ≤ 10^9

#### 解题思路

**核心思想：** 使用哈希表存储所有数字，然后对每个可能的序列起点，向后查找连续数字的长度。关键是只从序列起点开始查找，避免重复计算。

**算法步骤：**

1. 将所有数字存入哈希表，实现O(1)查找
2. 遍历数组中的每个数字：
   - 检查是否为序列起点（不存在num-1）
   - 如果是起点，向后查找连续数字
   - 记录当前序列长度，更新最大长度
3. 返回最长序列长度

**时间复杂度：** O(n) - 每个数字最多被访问两次（一次遍历，一次序列查找）
**空间复杂度：** O(n) - 哈希表存储所有数字

#### 代码实现

**Java版本：**

```java
public class LongestConsecutive {
   public int longestConsecutive(int[] nums) {
      if (nums.length == 0) return 0;

      // 哈希表存储所有数字，实现O(1)查找
      Set<Integer> numSet = new HashSet<>();
      for (int num : nums) {
         numSet.add(num);
      }

      int maxLength = 0;

      for (int num : numSet) {
         // 只检查序列的起点（不存在前驱数字num-1）
         if (!numSet.contains(num - 1)) {
            int currentNum = num;
            int currentLength = 1;

            // 向后查找连续数字
            while (numSet.contains(currentNum + 1)) {
               currentNum++;
               currentLength++;
            }

            maxLength = Math.max(maxLength, currentLength);
         }
      }

      return maxLength;
   }
}
```

**Kotlin版本：**

```kotlin
fun longestConsecutive(nums: IntArray): Int {
   if (nums.isEmpty()) return 0

   // 哈希表存储所有数字，实现O(1)查找
   val numSet = nums.toHashSet()
   var maxLength = 0

   for (num in numSet) {
      // 只检查序列的起点（不存在前驱数字num-1）
      if (!numSet.contains(num - 1)) {
         var currentNum = num
         var currentLength = 1

         // 向后查找连续数字
         while (numSet.contains(currentNum + 1)) {
            currentNum++
            currentLength++
         }

         maxLength = maxOf(maxLength, currentLength)
      }
   }

   return maxLength
}
```

**哈希表解法的优势：**

- 通过HashSet实现O(1)的查找时间复杂度
- 只从序列起点开始查找，避免重复遍历
- 无需排序，在O(n)时间内解决问题

## 双指针

### [移动零](https://leetcode.cn/problems/move-zeroes/)

**题目描述：**
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**注意：**

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

**示例：**

```
输入：nums = [0,1,0,3,12]
输出：[1,3,12,0,0]
解释：将所有0移动到末尾，非零元素保持相对顺序
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^4
- -2^31 ≤ nums[i] ≤ 2^31 - 1

#### 解题思路

**核心思想：** 使用双指针，一个指针遍历数组，另一个指针指向下一个非零元素应该放置的位置。遇到非零元素时，将其与指针位置的元素交换。

**算法步骤：**

1. 使用两个指针：`slow`（非零元素位置）和 `fast`（遍历指针）
2. 遍历数组：
   - 如果 `nums[fast] != 0`，将其与 `nums[slow]` 交换
   - 然后 `slow++`，确保下次非零元素放在正确位置
3. 继续直到遍历完整个数组

**时间复杂度：** O(n) - 只需要遍历一次数组
**空间复杂度：** O(1) - 原地操作，不需要额外空间

#### 代码实现

**Java版本：**

```java
public class MoveZeroes {
   public void moveZeroes(int[] nums) {
      int slow = 0; // 指向下一个非零元素应该放置的位置

      for (int fast = 0; fast < nums.length; fast++) {
         // 如果当前元素不为0，将其移动到slow位置
         if (nums[fast] != 0) {
            if (fast != slow) {
               // 交换元素
               int temp = nums[fast];
               nums[fast] = nums[slow];
               nums[slow] = temp;
            }
            slow++; // 更新下一个非零元素的位置
         }
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun moveZeroes(nums: IntArray) {
   var slow = 0 // 指向下一个非零元素应该放置的位置

   for (fast in nums.indices) {
      // 如果当前元素不为0，将其移动到slow位置
      if (nums[fast] != 0) {
         if (fast != slow) {
            // Kotlin的also语法实现交换
            nums[slow] = nums[fast].also { nums[fast] = nums[slow] }
         }
         slow++ // 更新下一个非零元素的位置
      }
   }
}
```

**双指针解法的优势：**

- 只需要一次遍历，时间复杂度O(n)
- 原地操作，空间复杂度O(1)
- 保持非零元素的相对顺序不变

### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

**题目描述：**
给定一个长度为 n 的整数数组 `height`。有 n 条垂线，第 i 条线的两个端点是 `(i, 0)` 和 `(i, height[i])`。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**注意：** 你不能倾斜容器。

**示例：**

```
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。
在此情况下，容器能够容纳水的最大值为 49。
```

**约束条件：**

- n == height.length
- 2 ≤ n ≤ 10^5
- 0 ≤ height[i] ≤ 10^4

#### 解题思路

**核心思想：** 使用双指针从两端向中间收缩。容器的面积由两个因素决定：宽度（两指针距离）和高度（两条线中较短的那条）。每次移动较短的那条线，因为移动较高的线不会增加面积。

**算法步骤：**

1. 初始化左右指针分别指向数组两端
2. 计算当前容器面积：`min(height[left], height[right]) × (right - left)`
3. 移动较短边的指针：
   - 如果 `height[left] < height[right]`，移动 `left++`
   - 否则移动 `right--`
4. 重复步骤2-3，直到两指针相遇

**时间复杂度：** O(n) - 每个元素最多被访问一次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class MaxArea {
   public int maxArea(int[] height) {
      int left = 0, right = height.length - 1;
      int maxWater = 0;

      while (left < right) {
         // 计算当前容器面积：宽度 × 高度（取较小值）
         int currentArea = Math.min(height[left], height[right]) * (right - left);
         maxWater = Math.max(maxWater, currentArea);

         // 移动较短的那条边
         if (height[left] < height[right]) {
            left++;
         } else {
            right--;
         }
      }

      return maxWater;
   }
}
```

**Kotlin版本：**

```kotlin
fun maxArea(height: IntArray): Int {
   var left = 0
   var right = height.lastIndex
   var maxWater = 0

   while (left < right) {
      // 计算当前容器面积：宽度 × 高度（取较小值）
      val currentArea = minOf(height[left], height[right]) * (right - left)
      maxWater = maxOf(maxWater, currentArea)

      // 移动较短的那条边，因为较短的边限制了容器的高度
      if (height[left] < height[right]) {
         left++
      } else {
         right--
      }
   }

   return maxWater
}
```

**双指针解法的优势：**

- 通过双指针避免了O(n²)的暴力解法
- 每次移动都是有意义的：移动较短边可能找到更大面积
- 一次遍历即可找到最优解

### [三数之和](https://leetcode.cn/problems/3sum/)

**题目描述：**
给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足
`nums[i] + nums[j] + nums[k] == 0`。

请你返回所有和为 0 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

**示例：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0
去重后，得到 [[-1,-1,2],[-1,0,1]]
```

**约束条件：**

- 3 ≤ nums.length ≤ 3000
- -10^5 ≤ nums[i] ≤ 10^5

#### 解题思路

**核心思想：** 先对数组排序，然后固定第一个数，使用双指针在剩余部分寻找两个数使得三数之和为0。排序后可以有效去重并进行剪枝优化。

**算法步骤：**

1. 对数组进行排序
2. 遍历数组，固定第一个数 `nums[i]`
3. 使用双指针在 `i+1` 到末尾的范围内寻找两个数
4. 如果三数之和等于0，记录结果并跳过重复元素
5. 如果和小于0，左指针右移；如果和大于0，右指针左移

**时间复杂度：** O(n²) - 外层循环O(n)，内层双指针O(n)
**空间复杂度：** O(1) - 不考虑结果存储的额外空间

#### 代码实现

**Java版本：**

```java
public class ThreeSum {
   public List<List<Integer>> threeSum(int[] nums) {
      List<List<Integer>> result = new ArrayList<>();
      Arrays.sort(nums); // 排序便于去重和剪枝

      for (int i = 0; i < nums.length - 2; i++) {
         // 跳过重复的第一个数
         if (i > 0 && nums[i] == nums[i - 1]) continue;

         // 剪枝：如果当前数大于0，后面都是正数，三数之和必然大于0
         if (nums[i] > 0) break;

         // 剪枝优化：当前数与最大两数之和仍小于0，跳过
         if (nums[i] + nums[nums.length - 2] + nums[nums.length - 1] < 0) continue;

         // 剪枝优化：当前数与最小两数之和大于0，无解
         if (nums[i] + nums[i + 1] + nums[i + 2] > 0) break;

         int left = i + 1, right = nums.length - 1;

         while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];

            if (sum == 0) {
               result.add(Arrays.asList(nums[i], nums[left], nums[right]));

               // 跳过重复的左右指针值
               do {
                  left++;
               } while (left < right && nums[left] == nums[left - 1]);

               do {
                  right--;
               } while (left < right && nums[right] == nums[right + 1]);
            } else if (sum < 0) {
               left++; // 和太小，左指针右移
            } else {
               right--; // 和太大，右指针左移
            }
         }
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun threeSum(nums: IntArray): List<List<Int>> {
   nums.sort() // 排序便于去重和剪枝
   val result = mutableListOf<List<Int>>()

   for (i in 0..nums.lastIndex - 2) {
      // 跳过重复的第一个数
      if (i > 0 && nums[i] == nums[i - 1]) continue

      // 剪枝：如果当前数大于0，后面都是正数，三数之和必然大于0
      if (nums[i] > 0) break

      // 剪枝优化：当前数与最大两数之和仍小于0，跳过
      if (nums[i] + nums[nums.lastIndex - 1] + nums[nums.lastIndex] < 0) continue

      // 剪枝优化：当前数与最小两数之和大于0，无解
      if (nums[i] + nums[i + 1] + nums[i + 2] > 0) break

      var left = i + 1
      var right = nums.lastIndex

      while (left < right) {
         val sum = nums[i] + nums[left] + nums[right]

         when {
            sum == 0 -> {
               result.add(listOf(nums[i], nums[left], nums[right]))

               // 跳过重复的左右指针值
               do {
                  left++
               } while (left < right && nums[left] == nums[left - 1])

               do {
                  right--
               } while (left < right && nums[right] == nums[right + 1])
            }
            sum < 0 -> left++  // 和太小，左指针右移
            else -> right--    // 和太大，右指针左移
         }
      }
   }

   return result
}
```

**双指针解法的优势：**

- 通过排序实现有效去重，避免重复三元组
- 双指针技巧将O(n³)暴力解法优化到O(n²)
- 多种剪枝策略进一步提升性能

### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)

**题目描述：**
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能够接多少雨水。

**示例：**

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，
在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）
```

**约束条件：**

- n == height.length
- 1 ≤ n ≤ 2 × 10^4
- 0 ≤ height[i] ≤ 3 × 10^4

#### 解题思路

**核心思想：** 使用双指针从两端向中间移动。根据木桶原理，某个位置能接的雨水量由该位置左右两边的最小值决定。通过维护左右两边的最大高度，可以确定当前位置的积水量。

**算法步骤：**

1. 初始化左右指针分别指向数组两端
2. 维护 `leftMax` 和 `rightMax` 分别记录左右两边的最大高度
3. 比较 `leftMax` 和 `rightMax`：
   - 如果 `leftMax < rightMax`，移动左指针，计算左边积水
   - 否则移动右指针，计算右边积水
4. 重复直到两指针相遇

**关键insight：** 当 `leftMax < rightMax` 时，左指针位置的积水量只取决于 `leftMax`，因为右边必然有更高的墙。

**时间复杂度：** O(n) - 每个元素访问一次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class Trap {
   public int trap(int[] height) {
      if (height.length < 3) return 0;

      int left = 0, right = height.length - 1;
      int leftMax = height[left], rightMax = height[right];
      int totalWater = 0;

      while (left < right) {
         if (leftMax < rightMax) {
            // 左边较低，移动左指针
            left++;
            if (height[left] < leftMax) {
               // 当前高度小于左边最大高度，可以接水
               totalWater += leftMax - height[left];
            } else {
               // 更新左边最大高度
               leftMax = height[left];
            }
         } else {
            // 右边较低或相等，移动右指针
            right--;
            if (height[right] < rightMax) {
               // 当前高度小于右边最大高度，可以接水
               totalWater += rightMax - height[right];
            } else {
               // 更新右边最大高度
               rightMax = height[right];
            }
         }
      }

      return totalWater;
   }
}
```

**Kotlin版本：**

```kotlin
fun trap(height: IntArray): Int {
   if (height.isEmpty() || height.size < 3) return 0

   var left = 0
   var right = height.lastIndex
   var leftMax = height[left]
   var rightMax = height[right]
   var totalWater = 0

   while (left < right) {
      if (leftMax < rightMax) {
         // 左边较低，移动左指针
         left++
         if (height[left] < leftMax) {
            // 当前高度小于左边最大高度，可以接水
            totalWater += leftMax - height[left]
         } else {
            // 更新左边最大高度
            leftMax = height[left]
         }
      } else {
         // 右边较低或相等，移动右指针
         right--
         if (height[right] < rightMax) {
            // 当前高度小于右边最大高度，可以接水
            totalWater += rightMax - height[right]
         } else {
            // 更新右边最大高度
            rightMax = height[right]
         }
      }
   }

   return totalWater
}
```

**双指针解法的优势：**

- 基于木桶原理，通过双指针优化空间复杂度到O(1)
- 避免了预处理左右最大值数组，节省空间
- 一次遍历即可完成计算，时间效率高

## 滑动窗口

### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

**题目描述：**
给定一个字符串 `s`，请你找出其中不含有重复字符的最长子串的长度。

**示例：**

```
输入：s = "abcabcbb"
输出：3
解释：因为无重复字符的最长子串是 "abc"，所以其长度为 3。

输入：s = "bbbbb"
输出：1
解释：因为无重复字符的最长子串是 "b"，所以其长度为 1。

输入：s = "pwwkew"
输出：3
解释：因为无重复字符的最长子串是 "wke"，所以其长度为 3。
```

**约束条件：**

- 0 ≤ s.length ≤ 5 × 10^4
- s 由英文字母、数字、符号和空格组成

#### 解题思路

**核心思想：** 使用滑动窗口技术，维护一个无重复字符的窗口。通过左右两个指针来控制窗口的大小，当发现重复字符时收缩左边界，扩展右边界时更新最大长度。

**算法步骤：**

1. 使用HashSet存储当前窗口中的字符，实现O(1)的查找和删除
2. 右指针逐个遍历字符串：
   - 如果当前字符已存在，收缩左边界直到去除重复字符
   - 将当前字符加入窗口
   - 更新最大长度
3. 重复直到右指针遍历完整个字符串

**时间复杂度：** O(n) - 每个字符最多被访问两次（加入和移除）
**空间复杂度：** O(min(m,n)) - m是字符集大小，n是字符串长度

#### 代码实现

**Java版本：**

```java
public class LengthOfLongestSubstring {
   public int lengthOfLongestSubstring(String s) {
      Set<Character> windowChars = new HashSet<>();

      int left = 0;
      int maxLength = 0;

      for (int right = 0; right < s.length(); right++) {
         char rightChar = s.charAt(right);

         // 如果遇到重复字符，收缩左边界直到去除重复
         while (windowChars.contains(rightChar)) {
            windowChars.remove(s.charAt(left));
            left++;
         }

         // 将当前字符加入窗口
         windowChars.add(rightChar);
         // 更新最大长度
         maxLength = Math.max(maxLength, right - left + 1);
      }

      return maxLength;
   }
}
```

**Kotlin版本：**

```kotlin
fun lengthOfLongestSubstring(s: String): Int {
   if (s.isEmpty()) return 0

   val windowChars = mutableSetOf<Char>()
   var left = 0
   var maxLength = 0

   for (right in s.indices) {
      val rightChar = s[right]

      // 如果遇到重复字符，收缩左边界直到去除重复
      while (rightChar in windowChars) {
         windowChars.remove(s[left])
         left++
      }

      // 将当前字符加入窗口
      windowChars.add(rightChar)
      // 更新最大长度
      maxLength = maxOf(maxLength, right - left + 1)
   }

   return maxLength
}
```

**滑动窗口解法的优势：**

- 通过HashSet实现O(1)的字符查找，避免嵌套循环
- 左右指针保证每个字符最多被访问两次，时间复杂度为O(n)
- 动态调整窗口大小，空间效率高

### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

**题目描述：**
给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

异位词指字母相同，但排列不同的字符串。

**示例：**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**约束条件：**

- 1 ≤ s.length, p.length ≤ 3 × 10^4
- s 和 p 仅包含小写字母

#### 解题思路

**核心思想：** 使用固定大小的滑动窗口，窗口大小等于目标字符串长度。通过字符频率匹配来判断当前窗口是否为异位词。

**算法步骤：**

1. 统计目标字符串p中每个字符的出现频率
2. 使用滑动窗口遍历字符串s：
   - 维护窗口大小为p的长度
   - 统计窗口内字符频率
   - 当窗口内字符频率与目标频率完全匹配时，记录起始位置
3. 移动窗口：移除左边字符，添加右边字符

**时间复杂度：** O(n) - n为字符串s的长度，每个字符最多被处理两次
**空间复杂度：** O(1) - 字符频率数组大小固定为26（小写字母）

#### 代码实现

**Java版本：**

```java
public class FindAnagrams {
   public List<Integer> findAnagrams(String s, String p) {
      List<Integer> result = new ArrayList<>();

      if (s.length() < p.length()) return result;

      // 统计目标字符串的字符频率
      int[] targetFreq = new int[26];
      for (char c : p.toCharArray()) {
         targetFreq[c - 'a']++;
      }

      // 统计滑动窗口的字符频率
      int[] windowFreq = new int[26];
      int windowSize = p.length();

      // 初始化第一个窗口
      for (int i = 0; i < windowSize; i++) {
         windowFreq[s.charAt(i) - 'a']++;
      }

      // 检查第一个窗口
      if (Arrays.equals(targetFreq, windowFreq)) {
         result.add(0);
      }

      // 滑动窗口
      for (int right = windowSize; right < s.length(); right++) {
         // 添加右边新字符
         windowFreq[s.charAt(right) - 'a']++;
         // 移除左边旧字符
         int left = right - windowSize;
         windowFreq[s.charAt(left) - 'a']--;

         // 检查当前窗口是否为异位词
         if (Arrays.equals(targetFreq, windowFreq)) {
            result.add(left + 1);
         }
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun findAnagrams(s: String, p: String): List<Int> {
   val result = mutableListOf<Int>()

   if (s.length < p.length) return result

   // 统计目标字符串的字符频率
   val targetFreq = IntArray(26)
   p.forEach { targetFreq[it - 'a']++ }

   // 统计滑动窗口的字符频率
   val windowFreq = IntArray(26)
   val windowSize = p.length

   // 初始化第一个窗口
   for (i in 0 until windowSize) {
      windowFreq[s[i] - 'a']++
   }

   // 检查第一个窗口
   if (targetFreq.contentEquals(windowFreq)) {
      result.add(0)
   }

   // 滑动窗口
   for (right in windowSize until s.length) {
      // 添加右边新字符
      windowFreq[s[right] - 'a']++
      // 移除左边旧字符
      val left = right - windowSize
      windowFreq[s[left] - 'a']--

      // 检查当前窗口是否为异位词
      if (targetFreq.contentEquals(windowFreq)) {
         result.add(left + 1)
      }
   }

   return result
}
```

**滑动窗口解法的优势：**

- 固定窗口大小，避免复杂的窗口调整逻辑
- 使用数组统计字符频率，比HashMap更高效
- 一次遍历完成所有匹配检测，时间复杂度为O(n)

## 子串

### [和为K的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

**题目描述：**
给你一个整数数组 `nums` 和一个整数 `k`，请你统计并返回该数组中和为 `k` 的连续子数组的个数。

**示例：**

```
输入：nums = [1,1,1], k = 2
输出：2
解释：连续子数组 [1,1] 与 [1,1] 的和都等于 2

输入：nums = [1,2,3], k = 3
输出：2
解释：连续子数组 [1,2] 与 [3] 的和都等于 3
```

**约束条件：**

- 1 ≤ nums.length ≤ 2 × 10^4
- -1000 ≤ nums[i] ≤ 1000
- -10^7 ≤ k ≤ 10^7

#### 解题思路

**核心思想：** 使用前缀和 + 哈希表的方法。对于任意子数组nums[i..j]，其和等于prefixSum[j+1] - prefixSum[i]
。如果这个和等于k，那么prefixSum[j+1] - prefixSum[i] = k，即prefixSum[i] = prefixSum[j+1] - k。

**算法步骤：**

1. 使用HashMap存储前缀和的出现次数
2. 遍历数组，计算当前前缀和
3. 检查 `currentPrefixSum - k` 是否在HashMap中存在
4. 如果存在，说明存在以当前位置结尾、和为k的子数组
5. 将当前前缀和加入HashMap

**时间复杂度：** O(n) - 只需要遍历一次数组
**空间复杂度：** O(n) - HashMap存储前缀和

#### 代码实现

**Java版本：**

```java
public class SubarraySum {
   public int subarraySum(int[] nums, int k) {
      // 记录前缀和的出现次数，初始化前缀和0出现1次（空数组）
      Map<Integer, Integer> prefixSumCount = new HashMap<>();
      prefixSumCount.put(0, 1);

      int count = 0;
      int currentPrefixSum = 0;

      for (int num : nums) {
         // 计算当前前缀和
         currentPrefixSum += num;

         // 查找是否存在前缀和为 currentPrefixSum - k
         // 如果存在，说明有子数组的和为k
         count += prefixSumCount.getOrDefault(currentPrefixSum - k, 0);

         // 更新当前前缀和的出现次数
         prefixSumCount.put(currentPrefixSum,
                 prefixSumCount.getOrDefault(currentPrefixSum, 0) + 1);
      }

      return count;
   }
}
```

**Kotlin版本：**

```kotlin
fun subarraySum(nums: IntArray, k: Int): Int {
   // 记录前缀和的出现次数，初始化前缀和0出现1次（空数组）
   val prefixSumCount = mutableMapOf<Int, Int>().withDefault { 0 }
   prefixSumCount[0] = 1

   var count = 0
   var currentPrefixSum = 0

   for (num in nums) {
      // 计算当前前缀和
      currentPrefixSum += num

      // 查找是否存在前缀和为 currentPrefixSum - k
      // 如果存在，说明有子数组的和为k
      count += prefixSumCount.getValue(currentPrefixSum - k)

      // 更新当前前缀和的出现次数
      prefixSumCount[currentPrefixSum] = prefixSumCount.getValue(currentPrefixSum) + 1
   }

   return count
}
```

**前缀和解法的优势：**

- 通过前缀和将子数组和问题转化为差值查找问题
- 使用HashMap实现O(1)的查找时间复杂度
- 一次遍历即可得到所有结果，避免嵌套循环

### [滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

**题目描述：**
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k`
个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^5
- -10^4 ≤ nums[i] ≤ 10^4
- 1 ≤ k ≤ nums.length

#### 解题思路

**核心思想：** 使用单调双端队列（Deque）维护一个单调递减的窗口。队列头部始终是当前窗口的最大值索引。

**算法步骤：**

1. 使用双端队列存储数组索引（不是值）
2. 维护队列单调递减性质：
   - 新元素入队前，移除队尾所有小于当前元素的索引
   - 确保队头索引在当前窗口范围内
3. 当窗口形成时，队头就是当前窗口的最大值

**时间复杂度：** O(n) - 每个元素最多入队和出队一次
**空间复杂度：** O(k) - 双端队列最多存储k个元素

#### 代码实现

**Java版本：**

```java
public class MaxSlidingWindow {
   public int[] maxSlidingWindow(int[] nums, int k) {
      if (nums.length == 0 || k <= 0) return new int[0];

      // 使用双端队列存储索引，维护单调递减
      Deque<Integer> deque = new ArrayDeque<>();
      int[] result = new int[nums.length - k + 1];

      for (int right = 0; right < nums.length; right++) {
         // 移除队尾所有小于当前元素的索引，维护单调递减
         while (!deque.isEmpty() && nums[deque.peekLast()] < nums[right]) {
            deque.pollLast();
         }

         // 当前索引入队
         deque.offerLast(right);

         // 计算左边界
         int left = right - k + 1;

         // 移除超出窗口范围的索引
         if (deque.peekFirst() < left) {
            deque.pollFirst();
         }

         // 当窗口形成时，记录最大值
         if (left >= 0) {
            result[left] = nums[deque.peekFirst()];
         }
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun maxSlidingWindow(nums: IntArray, k: Int): IntArray {
   if (nums.isEmpty() || k <= 0) return IntArray(0)

   // 使用双端队列存储索引，维护单调递减
   val deque = ArrayDeque<Int>()
   val result = IntArray(nums.size - k + 1)

   for (right in nums.indices) {
      // 移除队尾所有小于当前元素的索引，维护单调递减
      while (deque.isNotEmpty() && nums[deque.peekLast()] < nums[right]) {
         deque.pollLast()
      }

      // 当前索引入队
      deque.offerLast(right)

      // 计算左边界
      val left = right - k + 1

      // 移除超出窗口范围的索引
      if (deque.peekFirst() < left) {
         deque.pollFirst()
      }

      // 当窗口形成时，记录最大值
      if (left >= 0) {
         result[left] = nums[deque.peekFirst()]
      }
   }

   return result
}
```

**单调队列解法的优势：**

- 通过维护单调性，确保队头始终是窗口最大值
- 每个元素最多入队出队一次，时间复杂度为O(n)
- 避免了每次重新计算窗口最大值的开销

### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

**题目描述：**
给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串
`""`。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。

输入：s = "a", t = "aa"
输出：""
解释：t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子串。
```

**约束条件：**

- m == s.length
- n == t.length
- 1 ≤ m, n ≤ 10^5
- s 和 t 由英文字母组成

#### 解题思路

**核心思想：** 使用滑动窗口技术。先扩展右边界直到窗口包含所有目标字符，然后收缩左边界寻找最小窗口。

**算法步骤：**

1. 统计目标字符串t中每个字符的出现频率
2. 使用滑动窗口在s中寻找：
   - 扩展右边界，直到窗口包含t的所有字符
   - 收缩左边界，寻找最小覆盖窗口
   - 记录最小窗口的位置和长度
3. 返回最小覆盖子串

**时间复杂度：** O(m + n) - m和n分别是字符串s和t的长度
**空间复杂度：** O(k) - k是字符集大小

#### 代码实现

**Java版本：**

```java
public class MinWindow {
   public String minWindow(String s, String t) {
      if (s.length() < t.length()) return "";

      // 统计目标字符串中每个字符的出现频率
      Map<Character, Integer> targetFreq = new HashMap<>();
      for (char c : t.toCharArray()) {
         targetFreq.put(c, targetFreq.getOrDefault(c, 0) + 1);
      }

      // 统计当前窗口中每个字符的出现频率
      Map<Character, Integer> windowFreq = new HashMap<>();

      int left = 0;
      int matchCount = 0; // 已匹配的字符种类数
      int minLength = Integer.MAX_VALUE;
      int minStart = 0;

      for (int right = 0; right < s.length(); right++) {
         char rightChar = s.charAt(right);

         // 如果当前字符在目标字符串中
         if (targetFreq.containsKey(rightChar)) {
            windowFreq.put(rightChar, windowFreq.getOrDefault(rightChar, 0) + 1);

            // 如果当前字符的频率刚好匹配目标频率
            if (windowFreq.get(rightChar).equals(targetFreq.get(rightChar))) {
               matchCount++;
            }
         }

         // 当所有字符都匹配时，尝试收缩窗口
         while (matchCount == targetFreq.size()) {
            // 更新最小覆盖子串
            if (right - left + 1 < minLength) {
               minLength = right - left + 1;
               minStart = left;
            }

            char leftChar = s.charAt(left);
            left++;

            // 如果左边界字符在目标字符串中
            if (targetFreq.containsKey(leftChar)) {
               // 如果移除前字符频率刚好匹配，移除后就不匹配了
               if (windowFreq.get(leftChar).equals(targetFreq.get(leftChar))) {
                  matchCount--;
               }
               windowFreq.put(leftChar, windowFreq.get(leftChar) - 1);
            }
         }
      }

      return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);
   }
}
```

**Kotlin版本：**

```kotlin
fun minWindow(s: String, t: String): String {
   if (s.length < t.length) return ""

   // 统计目标字符串中每个字符的出现频率
   val targetFreq = mutableMapOf<Char, Int>().withDefault { 0 }
   t.forEach { targetFreq[it] = targetFreq.getValue(it) + 1 }

   // 统计当前窗口中每个字符的出现频率
   val windowFreq = mutableMapOf<Char, Int>().withDefault { 0 }

   var left = 0
   var matchCount = 0 // 已匹配的字符种类数
   var minLength = Int.MAX_VALUE
   var minStart = 0

   for (right in s.indices) {
      val rightChar = s[right]

      // 如果当前字符在目标字符串中
      if (rightChar in targetFreq) {
         windowFreq[rightChar] = windowFreq.getValue(rightChar) + 1

         // 如果当前字符的频率刚好匹配目标频率
         if (windowFreq[rightChar] == targetFreq[rightChar]) {
            matchCount++
         }
      }

      // 当所有字符都匹配时，尝试收缩窗口
      while (matchCount == targetFreq.size) {
         // 更新最小覆盖子串
         val currentLength = right - left + 1
         if (currentLength < minLength) {
            minLength = currentLength
            minStart = left
         }

         val leftChar = s[left]
         left++

         // 如果左边界字符在目标字符串中
         if (leftChar in targetFreq) {
            // 如果移除前字符频率刚好匹配，移除后就不匹配了
            if (windowFreq[leftChar] == targetFreq[leftChar]) {
               matchCount--
            }
            windowFreq[leftChar] = windowFreq.getValue(leftChar) - 1
         }
      }
   }

   return if (minLength == Int.MAX_VALUE) "" else s.substring(minStart, minStart + minLength)
}
```

**滑动窗口解法的优势：**

- 通过字符频率匹配精确控制窗口有效性
- 动态调整窗口大小，在保证覆盖的前提下寻找最小窗口
- 避免了暴力枚举所有子串的低效方法

## 普通数组

### [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

**题目描述：**
给你一个整数数组 `nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组是数组中的一个连续部分。

**示例：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。

输入：nums = [1]
输出：1
解释：只有一个元素。

输入：nums = [5,4,-1,7,8]
输出：23
解释：连续子数组 [5,4,-1,7,8] 的和最大，为 23。
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^5
- -10^4 ≤ nums[i] ≤ 10^4

#### 解题思路

**核心思想：** 使用Kadane算法（动态规划思想）。对于每个位置，决定是继续之前的子数组还是重新开始一个新的子数组。

**算法步骤：**

1. 设 dp[i] 表示以位置 i 结尾的最大子数组和。
2. 维护两个变量：当前子数组和、全局最大和
3. 遍历数组，对于每个元素：
   - 选择加入前面的子数组或重新开始：`max(当前元素, 前面子数组和 + 当前元素)`
   - 更新全局最大和
3. 返回全局最大和

**时间复杂度：** O(n) - 只需要遍历一次数组
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class MaxSubArray {
   public int maxSubArray(int[] nums) {
      int currentSum = nums[0];
      int maxSum = nums[0];

      for (int i = 1; i < nums.length; i++) {
         // 状态转移：选择加入前面的子数组或重新开始
         currentSum = Math.max(nums[i], currentSum + nums[i]);
         // 更新全局最大和
         maxSum = Math.max(maxSum, currentSum);
      }

      return maxSum;
   }
}
```

**Kotlin版本：**

```kotlin
fun maxSubArray(nums: IntArray): Int {
   var currentSum = nums[0]
   var maxSum = nums[0]

   for (i in 1 until nums.size) {
      // 状态转移：选择加入前面的子数组或重新开始
      currentSum = maxOf(nums[i], currentSum + nums[i])
      // 更新全局最大和
      maxSum = maxOf(maxSum, currentSum)
   }

   return maxSum
}
```

**Kadane算法的优势：**

- 一次遍历即可得到最优解，时间复杂度O(n)
- 空间复杂度O(1)，不需要额外数组存储
- 思路清晰：每个位置都做最优选择

### [合并区间](https://leetcode.cn/problems/merge-intervals/)

**题目描述：**
以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]`
。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**约束条件：**

- 1 ≤ intervals.length ≤ 10^4
- intervals[i].length == 2
- 0 ≤ starti ≤ endi ≤ 10^4

#### 解题思路

**核心思想：** 先按区间起始位置排序，然后依次判断当前区间与前一个区间是否重叠，如果重叠则合并，否则添加新区间。

**算法步骤：**

1. 按区间起始位置对所有区间排序
2. 遍历排序后的区间：
   - 如果当前区间与上一个区间不重叠，直接添加
   - 如果重叠，合并两个区间（更新结束位置为两者的最大值）
3. 返回合并后的区间列表

**时间复杂度：** O(n log n) - 排序的时间复杂度
**空间复杂度：** O(n) - 存储结果的额外空间

#### 代码实现

**Java版本：**

```java
public class Merge {
   public int[][] merge(int[][] intervals) {
      if (intervals.length <= 1) return intervals;

      // 按区间起始位置排序
      Arrays.sort(intervals, Comparator.comparingInt(interval -> interval[0]));

      List<int[]> mergedIntervals = new ArrayList<>();
      mergedIntervals.add(intervals[0]); // 添加第一个区间

      for (int i = 1; i < intervals.length; i++) {
         int[] currentInterval = intervals[i];
         int[] lastMergedInterval = mergedIntervals.get(mergedIntervals.size() - 1);

         // 如果当前区间与上一个区间重叠
         if (currentInterval[0] <= lastMergedInterval[1]) {
            // 合并区间：更新结束位置为两者的最大值
            lastMergedInterval[1] = Math.max(lastMergedInterval[1], currentInterval[1]);
         } else {
            // 不重叠，添加新区间
            mergedIntervals.add(currentInterval);
         }
      }

      return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
   }
}
```

**Kotlin版本：**

```kotlin
fun merge(intervals: Array<IntArray>): Array<IntArray> {
   if (intervals.size <= 1) return intervals

   // 按区间起始位置排序
   intervals.sortBy { it[0] }

   val mergedIntervals = mutableListOf<IntArray>()
   mergedIntervals.add(intervals[0]) // 添加第一个区间

   for (i in 1 until intervals.size) {
      val currentInterval = intervals[i]
      val lastMergedInterval = mergedIntervals.last()

      // 如果当前区间与上一个区间重叠
      if (currentInterval[0] <= lastMergedInterval[1]) {
         // 合并区间：更新结束位置为两者的最大值
         lastMergedInterval[1] = maxOf(lastMergedInterval[1], currentInterval[1])
      } else {
         // 不重叠，添加新区间
         mergedIntervals.add(currentInterval)
      }
   }

   return mergedIntervals.toTypedArray()
}
```

**排序+合并解法的优势：**

- 通过排序简化重叠判断逻辑
- 一次遍历完成所有合并操作
- 逻辑清晰，易于理解和实现

### [轮转数组](https://leetcode.cn/problems/rotate-array/)

**题目描述：**
给定一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例：**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释:
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^5
- -2^31 ≤ nums[i] ≤ 2^31 - 1
- 0 ≤ k ≤ 10^5

#### 解题思路

**核心思想：** 使用三次反转的技巧。先反转整个数组，再分别反转前k个元素和后n-k个元素。

#### 三次反转算法的数学证明

**问题定义**：将数组 `[a₀, a₁, a₂, ..., aₙ₋₁]` 向右轮转 `k` 个位置，得到 `[aₙ₋ₖ, aₙ₋ₖ₊₁, ..., aₙ₋₁, a₀, a₁, ..., aₙ₋ₖ₋₁]`

**主定理**：对数组执行以下三步操作等价于向右轮转 `k` 个位置：

1. 反转整个数组
2. 反转前 k 个元素
3. 反转后 n-k 个元素

**数学证明**：
设原数组为 `A = L + R`，其中：

- 左半部分：`L = [a₀, a₁, ..., aₙ₋ₖ₋₁]` (长度为 n-k)
- 右半部分：`R = [aₙ₋ₖ, aₙ₋ₖ₊₁, ..., aₙ₋₁]` (长度为 k)

目标数组：`A' = R + L`

**证明过程**：
设原数组为 `A = L + R`，目标数组为 `R + L`。

**所有可能的操作序列分析**：

**序列1（最优选择）：整个 → 前k → 后n-k**

```
A = L + R
→ reverse(L + R) = reverse(R) + reverse(L)
→ reverse(reverse(R)) + reverse(L) = R + reverse(L)
→ R + reverse(reverse(L)) = R + L ✓
```

**序列2（索引计算困难）：整个 → 后n-k → 前k**

```
A = L + R
→ reverse(L + R) = reverse(R) + reverse(L)
→ reverse(R) + reverse(reverse(L)) = reverse(R) + L
→ reverse(reverse(R)) + L = R + L ✓
```

**代码实现示例**：

```java
// 序列2的实现困难 虽然数学上正确，但第二步操作"后n-k个元素"的起始位置需要重新计算，增加了实现复杂度。
public void rotateSequence2(int[] nums, int k) {
   int n = nums.length;
   k = k % n;

   // 步骤1: 反转整个数组 [1,2,3,4,5,6,7] → [7,6,5,4,3,2,1]
   reverse(nums, 0, n - 1);

   // 步骤2: 反转后n-k个元素 - 难点：起始位置不直观
   // 原来的"后n-k个元素"现在在数组的什么位置？
   // 原数组后4个元素[4,5,6,7]反转后变成[7,6,5,4]，现在在前4个位置
   reverse(nums, 0, n - k - 1);  // [1,2,3,4,5,6,7] 经过全反转后需要反转[7,6,5,4]

   // 步骤3: 反转前k个元素 - 位置又变了
   reverse(nums, n - k, n - 1);
}
```

**序列3（索引追踪复杂）：前k → 后n-k → 整个**

```
A = L + R
→ reverse(L) + R
→ reverse(L) + reverse(R)
→ reverse(reverse(L) + reverse(R)) = reverse(reverse(R)) + reverse(reverse(L)) = R + L ✓
```

**代码实现示例**：

```java
// 序列3的实现困难 理论上正确，但前两步操作后各元素的位置完全改变，最后一步"整个数组"的边界难以确定。
public void rotateSequence4(int[] nums, int k) {
   int n = nums.length;
   k = k % n;

   // 步骤1: 反转前k个 [1,2,3,4,5,6,7] → [3,2,1,4,5,6,7]
   reverse(nums, 0, k - 1);

   // 步骤2: 反转后n-k个 [3,2,1,4,5,6,7] → [3,2,1,7,6,5,4]
   reverse(nums, k, n - 1);

   // 步骤3: 反转整个数组 - 难点：理解这一步的必要性
   // 为什么要反转整个[3,2,1,7,6,5,4]？很多程序员会困惑
   // 数学上正确，但逻辑不直观
   reverse(nums, 0, n - 1);  // → [4,5,6,7,1,2,3] ≠ [5,6,7,1,2,3,4]
}
```

**序列4（操作边界模糊）：后n-k → 前k → 整个**

```
A = L + R
→ L + reverse(R)
→ reverse(L) + reverse(R)
→ reverse(reverse(L) + reverse(R)) = R + L ✓
```

**代码实现示例**：

```java
// 序列4的实现困难 虽然数学上正确，但前两步操作的边界定义在实际编程中容易出错，可读性差。
public void rotateSequence6(int[] nums, int k) {
   int n = nums.length;
   k = k % n;

   // 步骤1: 反转后n-k个 - 难点：起始位置计算
   // [1,2,3,4,5,6,7] k=3，后4个是[4,5,6,7]，起始位置是n-k=4？
   // 容易写成 reverse(nums, n-k, n-1) 但这样对吗？
   reverse(nums, n - (n - k), n - 1);  // 复杂的索引计算

   // 步骤2: 反转前k个 - 难点：前面的操作影响了理解
   // 现在数组变成[1,2,3,7,6,5,4]，"前k个"是指哪k个？
   // 是原来的前k个[1,2,3]，还是当前的前k个[1,2,3]？
   reverse(nums, 0, k - 1);  // [3,2,1,7,6,5,4]

   // 步骤3: 反转整个数组
   reverse(nums, 0, n - 1);  // [4,5,6,7,1,2,3]
}
```

**序列5（数学上错误）：前k → 整个 → 后n-k**

```
A = L + R
→ reverse(L) + R
→ reverse(reverse(L) + R) = reverse(R) + reverse(reverse(L)) = reverse(R) + L
→ reverse(R) + reverse(L) ≠ R + L ❌
```

**序列6（数学上错误）：后n-k → 整个 → 前k**

```
A = L + R
→ L + reverse(R)
→ reverse(L + reverse(R)) = reverse(reverse(R)) + reverse(L) = R + reverse(L)
→ reverse(R) + reverse(L) ≠ R + L ❌
```

**关键洞察**：
虽然理论上存在多个可能正确的序列，但只有"整个 → 前k → 后n-k"这个序列在实际操作中：

1. **索引简单**：每次操作的边界都很清晰
2. **逻辑直观**：符合分治思想，先整体变换，再局部调整
3. **实现容易**：不需要复杂的索引计算

**时间复杂度：** O(n) - 每个元素最多被反转3次
**空间复杂度：** O(1) - 原地操作，不需要额外空间

#### 代码实现

**Java版本：**

```java
public class Rotate {
   public void rotate(int[] nums, int k) {
      int n = nums.length;
      k = k % n; // 避免无效轮转

      if (k == 0) return;

      // 反转整个数组
      reverse(nums, 0, n - 1);
      // 反转前k个元素
      reverse(nums, 0, k - 1);
      // 反转后n-k个元素
      reverse(nums, k, n - 1);
   }

   private void reverse(int[] nums, int start, int end) {
      while (start < end) {
         int temp = nums[start];
         nums[start] = nums[end];
         nums[end] = temp;
         start++;
         end--;
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun rotate(nums: IntArray, k: Int): Unit {
   val n = nums.size
   val effectiveK = k % n // 避免无效轮转

   if (effectiveK == 0) return

   // 扩展函数：反转数组的指定区间
   fun IntArray.reverseRange(start: Int, end: Int) {
      var left = start
      var right = end
      while (left < right) {
         val temp = this[left]
         this[left] = this[right]
         this[right] = temp
         left++
         right--
      }
   }

   // 反转整个数组
   nums.reverseRange(0, n - 1)
   // 反转前k个元素
   nums.reverseRange(0, effectiveK - 1)
   // 反转后n-k个元素
   nums.reverseRange(effectiveK, n - 1)
}
```

**三次反转解法的优势：**

- 空间复杂度O(1)，原地操作
- 逻辑巧妙，通过数学技巧避免复杂的元素移动
- 时间复杂度O(n)，每个元素最多被访问3次

### [除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

**题目描述：**
给你一个整数数组 `nums`，返回数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

题目数据保证数组 `nums` 之中任意元素的全部前缀元素和后缀元素的乘积都在 32 位整数范围内。

请不要使用除法，且在 O(n) 时间复杂度内完成此题。

**示例：**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**约束条件：**

- 2 ≤ nums.length ≤ 10^5
- -30 ≤ nums[i] ≤ 30
- 保证数组 nums 之中任意元素的全部前缀元素和后缀元素的乘积都在 32 位整数范围内

#### 解题思路

**核心思想：** 对于每个位置i，其结果等于左侧所有元素的乘积 × 右侧所有元素的乘积。通过两次遍历分别计算左侧乘积和右侧乘积。

**算法步骤：**

1. 第一次遍历：计算每个位置左侧所有元素的乘积
2. 第二次遍历：计算每个位置右侧所有元素的乘积，并与左侧乘积相乘得到最终结果
3. 优化：使用结果数组存储左侧乘积，用一个变量存储右侧乘积

**时间复杂度：** O(n) - 两次遍历数组
**空间复杂度：** O(1) - 不考虑输出数组的额外空间

#### 代码实现

**Java版本：**

```java
public class ProductExceptSelf {
   public int[] productExceptSelf(int[] nums) {
      int n = nums.length;
      int[] result = new int[n];

      // 第一次遍历：计算左侧乘积
      result[0] = 1; // 第一个元素左侧没有元素，乘积为1
      for (int i = 1; i < n; i++) {
         result[i] = result[i - 1] * nums[i - 1];
      }

      // 第二次遍历：计算右侧乘积并与左侧乘积相乘
      int rightProduct = 1; // 右侧乘积的累积值
      for (int i = n - 1; i >= 0; i--) {
         result[i] *= rightProduct; // 左侧乘积 × 右侧乘积
         rightProduct *= nums[i]; // 更新右侧乘积
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun productExceptSelf(nums: IntArray): IntArray {
   val n = nums.size
   val result = IntArray(n)

   // 第一次遍历：计算左侧乘积
   result[0] = 1 // 第一个元素左侧没有元素，乘积为1
   for (i in 1 until n) {
      result[i] = result[i - 1] * nums[i - 1]
   }

   // 第二次遍历：计算右侧乘积并与左侧乘积相乘
   var rightProduct = 1 // 右侧乘积的累积值
   for (i in n - 1 downTo 0) {
      result[i] *= rightProduct // 左侧乘积 × 右侧乘积
      rightProduct *= nums[i] // 更新右侧乘积
   }

   return result
}
```

**左右乘积解法的优势：**

- 不使用除法，避免除零等边界问题
- 时间复杂度O(n)，空间复杂度O(1)（不考虑输出数组）
- 通过两次遍历巧妙地计算出每个位置的结果

### [缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

**题目描述：**
给你一个未排序的整数数组 `nums`，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

**示例：**

```
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。

输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。

输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^5
- -2^31 ≤ nums[i] ≤ 2^31 - 1

#### 解题思路

**核心思想：** 使用数组本身作为哈希表。对于长度为n的数组，缺失的第一个正数一定在[1, n+1]
范围内。将每个有效数字放到其对应的位置上（数字k放到索引k-1处），然后查找第一个不在正确位置的数字。

**算法步骤：**

1. 第一次遍历：将每个有效数字（1≤num≤n）放到正确位置
   - 数字k应该放在索引k-1的位置
   - 使用交换操作，避免丢失数据
2. 第二次遍历：查找第一个不在正确位置的索引
3. 如果所有位置都正确，返回n+1

**时间复杂度：** O(n) - 每个元素最多被交换一次
**空间复杂度：** O(1) - 原地操作，不使用额外空间

#### 代码实现

**Java版本：**

```java
public class FirstMissingPositive {
   public int firstMissingPositive(int[] nums) {
      int n = nums.length;

      // 第一次遍历：将每个数放到它应该在的位置上
      for (int i = 0; i < n; i++) {
         // 当前数在有效范围内且不在正确位置上时，将其交换到正确位置
         while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
            // 交换 nums[i] 和 nums[nums[i] - 1]
            int temp = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = temp;
         }
      }

      // 第二次遍历：找到第一个不在正确位置上的元素
      for (int i = 0; i < n; i++) {
         if (nums[i] != i + 1) {
            return i + 1;
         }
      }

      // 如果所有元素都在正确位置上，返回n+1
      return n + 1;
   }
}
```

**Kotlin版本：**

```kotlin
fun firstMissingPositive(nums: IntArray): Int {
   val n = nums.size

   // 第一次遍历：将每个数放到它应该在的位置上
   for (i in 0 until n) {
      // 当前数在有效范围内且不在正确位置上时，将其交换到正确位置
      while (nums[i] in 1..n && nums[nums[i] - 1] != nums[i]) {
         // 交换 nums[i] 和 nums[nums[i] - 1]
         val temp = nums[nums[i] - 1]
         nums[nums[i] - 1] = nums[i]
         nums[i] = temp
      }
   }

   // 第二次遍历：找到第一个不在正确位置上的元素
   for (i in 0 until n) {
      if (nums[i] != i + 1) {
         return i + 1
      }
   }

   // 如果所有元素都在正确位置上，返回n+1
   return n + 1
}
```

**原地哈希解法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)，满足题目要求
- 巧妙利用数组索引和值的对应关系
- 通过原地交换避免使用额外的哈希表

## 矩阵

### [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

**题目描述：**
给定一个 `m x n` 的矩阵，如果一个元素为 `0`，则将其所在行和列的所有元素都设为 `0`。请使用原地算法。

**示例：**

```
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]

输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

**约束条件：**

- m == matrix.length
- n == matrix[0].length
- 1 ≤ m, n ≤ 200
- -2^31 ≤ matrix[i][j] ≤ 2^31 - 1

#### 解题思路

**核心思想：** 使用两个集合分别记录需要置零的行和列，然后统一进行置零操作。这样避免了在遍历过程中修改矩阵导致的干扰。

**算法步骤：**

1. 第一次遍历：扫描整个矩阵，记录所有包含0的行号和列号
2. 第二次遍历：将记录的行和列的所有元素置为0
3. 使用HashSet存储行列索引，避免重复操作

**时间复杂度：** O(m × n) - 需要遍历整个矩阵两次
**空间复杂度：** O(m + n) - 存储行列索引的HashSet

#### 代码实现

**Java版本：**

```java
public class SetZeroes {
   public void setZeroes(int[][] matrix) {
      Set<Integer> zeroRows = new HashSet<>();
      Set<Integer> zeroCols = new HashSet<>();
      int rows = matrix.length;
      int cols = matrix[0].length;

      // 第一次遍历：找出所有包含0的行和列
      for (int row = 0; row < rows; row++) {
         for (int col = 0; col < cols; col++) {
            if (matrix[row][col] == 0) {
               zeroRows.add(row);
               zeroCols.add(col);
            }
         }
      }

      // 第二次遍历：将对应行和列的元素置为0
      for (int row = 0; row < rows; row++) {
         for (int col = 0; col < cols; col++) {
            if (zeroRows.contains(row) || zeroCols.contains(col)) {
               matrix[row][col] = 0;
            }
         }
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun setZeroes(matrix: Array<IntArray>): Unit {
   val zeroRows = mutableSetOf<Int>()
   val zeroCols = mutableSetOf<Int>()

   // 第一次遍历：找出所有包含0的行和列
   matrix.forEachIndexed { row, rowArray ->
      rowArray.forEachIndexed { col, value ->
         if (value == 0) {
            zeroRows.add(row)
            zeroCols.add(col)
         }
      }
   }

   // 第二次遍历：将对应行和列的元素置为0
   matrix.forEachIndexed { row, rowArray ->
      rowArray.forEachIndexed { col, _ ->
         if (row in zeroRows || col in zeroCols) {
            matrix[row][col] = 0
         }
      }
   }
}
```

**两次遍历解法的优势：**

- 避免在遍历过程中修改矩阵，确保逻辑正确性
- 使用HashSet实现O(1)的查找时间复杂度
- 代码逻辑清晰，易于理解和维护

### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

**题目描述：**
给你一个 `m` 行 `n` 列的矩阵 `matrix`，请按照顺时针螺旋顺序，返回矩阵中的所有元素。

**示例：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**约束条件：**

- m == matrix.length
- n == matrix[i].length
- 1 ≤ m, n ≤ 10
- -100 ≤ matrix[i][j] ≤ 100

#### 解题思路

**核心思想：** 使用四个边界变量（top, bottom, left, right）来控制螺旋遍历的范围。按照"右→下→左→上"
的顺序逐层遍历，每完成一个方向的遍历就收缩对应的边界。

**算法步骤：**

1. 初始化四个边界：top=0, bottom=m-1, left=0, right=n-1
2. 循环遍历，每次按顺序执行：
   - 从左到右遍历上边界，然后top++
   - 从上到下遍历右边界，然后right--
   - 从右到左遍历下边界（需检查是否还有行），然后bottom--
   - 从下到上遍历左边界（需检查是否还有列），然后left++
3. 继续直到所有元素被访问

**为什么后两步需要边界检查？**

当矩阵退化为单行或单列时，前两步可能已经遍历了所有或部分元素，后两步如果不检查会重复访问：

**单行矩阵示例**：`[[1, 2, 3]]`

```
步骤1: 遍历[1,2,3] → top=1
步骤2: 无元素（top > bottom）
步骤3: 如果不检查，会重复遍历[2,1] ❌
```

**单列矩阵示例**：`[[1], [2], [3]]`

```
步骤1: 遍历[1] → top=1
步骤2: 遍历[2,3] → right=-1
步骤4: 如果不检查，会重复遍历[3,2] ❌
```

因此需要：

- **步骤3检查 `top <= bottom`**：确保还有未遍历的行
- **步骤4检查 `left <= right`**：确保还有未遍历的列

**时间复杂度：** O(m × n) - 每个元素恰好被访问一次
**空间复杂度：** O(1) - 不考虑输出数组的额外空间

#### 代码实现

**Java版本：**

```java
public class SpiralOrder {
   public List<Integer> spiralOrder(int[][] matrix) {
      if (matrix.length == 0) return new ArrayList<>();

      List<Integer> result = new ArrayList<>();
      int top = 0, bottom = matrix.length - 1;
      int left = 0, right = matrix[0].length - 1;

      while (top <= bottom && left <= right) {
         // 1. 从左到右遍历上边界
         for (int col = left; col <= right; col++) {
            result.add(matrix[top][col]);
         }
         top++;

         // 2. 从上到下遍历右边界
         for (int row = top; row <= bottom; row++) {
            result.add(matrix[row][right]);
         }
         right--;

         // 3. 从右到左遍历下边界（如果存在剩余行）
         if (top <= bottom) {
            for (int col = right; col >= left; col--) {
               result.add(matrix[bottom][col]);
            }
            bottom--;
         }

         // 4. 从下到上遍历左边界（如果存在剩余列）
         if (left <= right) {
            for (int row = bottom; row >= top; row--) {
               result.add(matrix[row][left]);
            }
            left++;
         }
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun spiralOrder(matrix: Array<IntArray>): List<Int> {
   if (matrix.isEmpty()) return emptyList()

   val result = mutableListOf<Int>()
   var top = 0
   var bottom = matrix.lastIndex
   var left = 0
   var right = matrix[0].lastIndex

   while (top <= bottom && left <= right) {
      // 1. 从左到右遍历上边界
      for (col in left..right) {
         result.add(matrix[top][col])
      }
      top++

      // 2. 从上到下遍历右边界
      for (row in top..bottom) {
         result.add(matrix[row][right])
      }
      right--

      // 3. 从右到左遍历下边界（如果存在剩余行）
      if (top <= bottom) {
         for (col in right downTo left) {
            result.add(matrix[bottom][col])
         }
         bottom--
      }

      // 4. 从下到上遍历左边界（如果存在剩余列）
      if (left <= right) {
         for (row in bottom downTo top) {
            result.add(matrix[row][left])
         }
         left++
      }
   }

   return result
}
```

**边界控制解法的优势：**

- 通过四个边界变量精确控制遍历范围
- 避免使用额外的visited数组，节省空间
- 逻辑清晰，每个方向的遍历都有明确的边界条件

### [旋转图像](https://leetcode.cn/problems/rotate-image/)

**题目描述：**
给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

**示例：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**约束条件：**

- n == matrix.length == matrix[i].length
- 1 ≤ n ≤ 20
- -1000 ≤ matrix[i][j] ≤ 1000

#### 解题思路

**核心思想：** 分层旋转，每次处理一个同心圆环。对于每个环，通过四个位置的循环交换实现90度旋转。

**算法步骤：**

1. 确定需要处理的层数：n/2层（最外层到最内层）
2. 对于每一层：
   - 确定当前层的边界
   - 沿着当前层的边界进行四元素循环交换
   - 交换规律：(i,j) → (j,n-1-i) → (n-1-i,n-1-j) → (n-1-j,i) → (i,j)
3. 处理完所有层后完成旋转

**为什么是 n/2 层？关键洞察**：

每一层都是一个"洋葱皮"结构，从外到内处理：

**偶数阶矩阵**（如4×4）：

```
[ 1  2  3  4]    层0: 外围一圈
[ 5  6  7  8]    层1: 内部一圈
[ 9 10 11 12]    需要处理 4/2=2 层
[13 14 15 16]
```

**奇数阶矩阵**（如3×3）：

```
[1 2 3]    层0: 外围一圈
[4 5 6]    中心元素5不需要旋转
[7 8 9]    需要处理 3/2=1 层
```

**层边界定义**：对于第 `layer` 层

- 上边界：`row = layer`
- 下边界：`row = n-1-layer`
- 左边界：`col = layer`
- 右边界：`col = n-1-layer`

**n/2设计的巧妙之处**：

- **自动处理奇偶差异**：整数除法确保奇数矩阵的中心元素不被处理
- **层次递进**：从外到内逐层旋转
- **边界清晰**：每层边界计算统一简单

**时间复杂度：** O(n²) - 每个元素被访问一次
**空间复杂度：** O(1) - 原地旋转，只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class Rotate {
   public void rotate(int[][] matrix) {
      int n = matrix.length;

      // 分层处理，每次处理一个同心圆环
      for (int layer = 0; layer < n / 2; layer++) {
         int first = layer;
         int last = n - 1 - layer;

         // 处理当前层的每个位置
         for (int offset = first; offset < last; offset++) {
            // 保存top位置的值
            int temp = matrix[first][offset];

            // left → top
            matrix[first][offset] = matrix[last - (offset - first)][first];

            // bottom → left
            matrix[last - (offset - first)][first] = matrix[last][last - (offset - first)];

            // right → bottom
            matrix[last][last - (offset - first)] = matrix[offset][last];

            // temp(top) → right
            matrix[offset][last] = temp;
         }
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun rotate(matrix: Array<IntArray>): Unit {
   val n = matrix.size

   // 分层处理，每次处理一个同心圆环
   for (layer in 0 until n / 2) {
      val first = layer
      val last = n - 1 - layer

      // 处理当前层的每个位置
      for (offset in first until last) {
         // 保存top位置的值
         val temp = matrix[first][offset]

         // left → top
         matrix[first][offset] = matrix[last - (offset - first)][first]

         // bottom → left
         matrix[last - (offset - first)][first] = matrix[last][last - (offset - first)]

         // right → bottom
         matrix[last][last - (offset - first)] = matrix[offset][last]

         // temp(top) → right
         matrix[offset][last] = temp
      }
   }
}
```

**分层旋转解法的优势：**

- 原地操作，空间复杂度O(1)
- 通过数学规律实现精确的位置映射
- 分层处理使逻辑更清晰，避免边界问题

### [搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

**题目描述：**
编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target`。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

**示例：**

```
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

**约束条件：**

- m == matrix.length
- n == matrix[i].length
- 1 ≤ n, m ≤ 300
- -10^9 ≤ matrix[i][j] ≤ 10^9
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- -10^9 ≤ target ≤ 10^9

#### 解题思路

**核心思想：** 利用矩阵的有序性质，从右上角（或左下角）开始搜索。根据当前值与目标值的比较结果，选择向左移动（减小值）或向下移动（增大值）。

**算法步骤：**

1. 从右上角开始：row = 0, col = n-1
2. 比较当前元素与目标值：
   - 如果相等，返回true
   - 如果当前值大于目标值，向左移动（col--）
   - 如果当前值小于目标值，向下移动（row++）
3. 如果越界仍未找到，返回false

**时间复杂度：** O(m + n) - 最多移动m+n次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class SearchMatrixII {
   public boolean searchMatrix(int[][] matrix, int target) {
      if (matrix.length == 0 || matrix[0].length == 0) return false;

      int rows = matrix.length;
      int cols = matrix[0].length;

      // 从右上角开始搜索
      int row = 0;
      int col = cols - 1;

      while (row < rows && col >= 0) {
         int currentValue = matrix[row][col];

         if (currentValue == target) {
            return true;
         } else if (currentValue > target) {
            col--; // 当前值太大，向左移动
         } else {
            row++; // 当前值太小，向下移动
         }
      }

      return false;
   }
}
```

**Kotlin版本：**

```kotlin
fun searchMatrixII(matrix: Array<IntArray>, target: Int): Boolean {
   if (matrix.isEmpty() || matrix[0].isEmpty()) return false

   val rows = matrix.size
   val cols = matrix[0].size

   // 从右上角开始搜索
   var row = 0
   var col = cols - 1

   while (row < rows && col >= 0) {
      when {
         matrix[row][col] == target -> return true
         matrix[row][col] > target -> col-- // 当前值太大，向左移动
         else -> row++ // 当前值太小，向下移动
      }
   }

   return false
}
```

**右上角搜索解法的优势：**

- 充分利用矩阵的双向有序性质
- 每次比较都能排除一行或一列，搜索效率高
- 时间复杂度O(m+n)，优于暴力搜索的O(mn)

## 链表

### [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

**题目描述：**
给你两个单链表的头节点 `headA` 和 `headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`。

题目数据保证整个链式结构中不存在环。

**示例：**

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'

输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
```

**约束条件：**

- listA 中节点数目为 m
- listB 中节点数目为 n
- 1 ≤ m, n ≤ 3 × 10^4
- 1 ≤ Node.val ≤ 10^5
- 0 ≤ skipA ≤ m
- 0 ≤ skipB ≤ n

#### 解题思路

**核心思想：** 使用双指针技巧。让两个指针分别遍历两个链表，当一个指针到达链表末尾时，将其重定向到另一个链表的头部。这样两个指针最终会在相交点相遇（如果存在），或者同时到达null（如果不存在相交点）。

**为什么链表末尾定义为null而不是最后一个元素？**

这是链表数据结构的基础概念，对理解相交链表算法至关重要：

**链表节点结构**：

```java
class ListNode {
   int val;        // 数据域
   ListNode next;  // 指针域 - 链表的核心
}
```

**概念区分**：

```
[1] -> [2] -> [3] -> null
 ^      ^      ^      ^
节点1   节点2  最后节点  链表末尾
```

- **最后一个节点**：存储数据的节点（如值为3的节点）
- **链表末尾**：最后一个节点的next指针，值为null

**null作为末尾的关键作用**：

1. **终止条件**：提供清晰的遍历终止标志

```java
while(current !=null){  // null作为终止条件

process(current);

current =current.next;
}
```

2. **相交判断的基础**：相交链表最终都指向同一个null

```java
链表A:[1]->[2]->[3]->null
链表B:[4]->[5]->[3]->null  // [3]是同一个节点对象
```

3. **算法简洁性**：双指针法的核心逻辑依赖null判断

```java
while(pA !=pB){
pA =(pA ==null)?headB :pA.next;
pB =(pB ==null)?headA :pB.next;
}
// 相交：在交点相遇；不相交：都变成null后相等
```

**如果定义末尾为最后元素的问题**：

- 无法表示空链表
- 遍历逻辑复杂，需要特殊处理最后一个节点
- 相交判断困难，失去统一的终止条件

**算法步骤：**

1. 初始化两个指针分别指向两个链表的头部
2. 同时移动两个指针：
   - 当指针A到达链表A末尾时，重定向到链表B的头部
   - 当指针B到达链表B末尾时，重定向到链表A的头部
3. 如果存在相交点，两个指针会在相交点相遇
4. 如果不存在相交点，两个指针会同时变为null

**时间复杂度：** O(m + n) - 每个指针最多遍历两个链表一次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class GetIntersectionNode {
   public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
      if (headA == null || headB == null) return null;

      ListNode pointerA = headA;
      ListNode pointerB = headB;

      // 当两个指针不相等时继续遍历
      while (pointerA != pointerB) {
         // 当指针A到达末尾时，重定向到链表B的头部
         pointerA = (pointerA != null) ? pointerA.next : headB;
         // 当指针B到达末尾时，重定向到链表A的头部
         pointerB = (pointerB != null) ? pointerB.next : headA;
      }

      // 返回相交节点（如果不存在则为null）
      return pointerA;
   }
}
```

**Kotlin版本：**

```kotlin
fun getIntersectionNode(headA: ListNode?, headB: ListNode?): ListNode? {
   if (headA == null || headB == null) return null

   var pointerA = headA
   var pointerB = headB

   while (pointerA !== pointerB) {
      // 当pointerA到达链表末尾时，重定向到链表B的头部
      pointerA = if (pointerA == null) headB else pointerA.next

      // 当pointerB到达链表末尾时，重定向到链表A的头部
      pointerB = if (pointerB == null) headA else pointerB.next
   }

   // 返回相交节点（如果不存在则为null）
   return pointerA
}
```

**双指针解法的优势：**

- 无需计算链表长度，自动处理长度差异
- 时间复杂度O(m+n)，空间复杂度O(1)
- 逻辑简洁，利用数学性质巧妙解决问题

### [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

**题目描述：**
给你单链表的头节点 `head`，请你反转链表，并返回反转后的链表。

**示例：**

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

输入：head = [1,2]
输出：[2,1]

输入：head = []
输出：[]
```

**约束条件：**

- 链表中节点的数目范围是 [0, 5000]
- -5000 ≤ Node.val ≤ 5000

#### 解题思路

**核心思想：** 使用三个指针（prev, current, next）进行迭代反转。通过改变每个节点的next指针方向来实现链表反转。

**算法步骤：**

1. 初始化三个指针：prev=null, current=head, next=null
2. 遍历链表，对每个节点：
   - 保存下一个节点：next = current.next
   - 反转当前节点指针：current.next = prev
   - 移动指针：prev = current, current = next
3. 返回prev作为新的头节点

**时间复杂度：** O(n) - 遍历链表一次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class ReverseList {
   public ListNode reverseList(ListNode head) {
      ListNode prev = null;
      ListNode current = head;

      while (current != null) {
         ListNode next = current.next;
         current.next = prev;
         prev = current;
         current = next;
      }

      return prev;
   }
}
```

**Kotlin版本：**

```kotlin
fun reverseList(head: ListNode?): ListNode? {
   var prev: ListNode? = null
   var current = head

   while (current != null) {
      val next = current.next
      current.next = prev
      prev = current
      current = next
   }

   return prev
}
```

**迭代反转解法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)
- 原地操作，不需要额外存储空间
- 逻辑清晰，易于理解和实现

### [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

**题目描述：**
给你一个单链表的头节点 `head`，请你判断该链表是否为回文链表。如果是，返回 `true`；否则，返回 `false`。

**示例：**

```
输入：head = [1,2,2,1]
输出：true

输入：head = [1,2]
输出：false
```

**约束条件：**

- 链表中节点数目在范围 [1, 10^5] 内
- 0 ≤ Node.val ≤ 9

#### 解题思路

**核心思想：** 使用快慢指针找到链表中点，然后反转后半部分链表，最后比较前后两半部分是否相同。

**算法步骤：**

1. 使用快慢指针找到链表的中点位置
2. 反转后半部分链表
3. 同时遍历前半部分和反转后的后半部分，比较节点值
4. 如果所有对应位置的值都相等，则为回文链表

**如何处理奇数链表？关键洞察**：

奇数链表的中间元素处理是算法的巧妙之处：

**奇数链表示例**：`[1,2,3,2,1]`

```
快慢指针停留位置:
链表: 1 -> 2 -> 3 -> 2 -> 1
           s         f      (循环结束时)
```

**分割策略**：

```
前半部分: 1 -> 2 -> 3     (从head到slow)
后半部分: 2 -> 1          (从slow.next开始)
反转后半部分: 1 -> 2
```

**比较过程**：

```
前半部分: 1 -> 2 -> 3
后半部分: 1 -> 2

比较配对: (1,1)✓, (2,2)✓
中间元素3被自动跳过！
```

**为什么中间元素不需要比较？**

1. **回文对称性**：奇数长度回文中，中间元素没有对称伙伴
2. **算法设计**：通过选择合适的分割点，自动忽略中间元素
3. **比较终止**：后半部分较短，比较在合适位置停止

这种设计使得同一套算法可以优雅地处理奇数和偶数链表，无需特殊判断。

**时间复杂度：** O(n) - 需要遍历链表两次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class IsPalindrome {
   public boolean isPalindrome(ListNode head) {
      if (head == null || head.next == null) {
         return true;
      }

      // 找到链表的中点
      ListNode middle = findMiddle(head);

      // 反转后半部分链表
      ListNode secondHalf = reverseList(middle.next);
      ListNode secondHalfHead = secondHalf; // 保存用于恢复

      // 比较前半部分和反转后的后半部分
      boolean isPalindrome = true;
      ListNode firstHalf = head;

      while (secondHalf != null) {
         if (firstHalf.val != secondHalf.val) {
            isPalindrome = false;
            break;
         }
         firstHalf = firstHalf.next;
         secondHalf = secondHalf.next;
      }

      // 可选：恢复链表原始结构
      // middle.next = reverseList(secondHalfHead);

      return isPalindrome;
   }

   private ListNode findMiddle(ListNode head) {
      ListNode slow = head;
      ListNode fast = head;

      while (fast.next != null && fast.next.next != null) {
         slow = slow.next;
         fast = fast.next.next;
      }

      return slow;
   }

   private ListNode reverseList(ListNode head) {
      ListNode prev = null;
      ListNode current = head;

      while (current != null) {
         ListNode next = current.next;
         current.next = prev;
         prev = current;
         current = next;
      }

      return prev;
   }
}
```

**Kotlin版本：**

```kotlin
fun isPalindrome(head: ListNode?): Boolean {
   if (head?.next == null) return true

   fun findMiddle(head: ListNode): ListNode {
      var slow = head
      var fast = head

      while (fast.next?.next != null) {
         slow = slow.next!!
         fast = fast.next!!.next!!
      }

      return slow
   }

   fun reverseList(head: ListNode?): ListNode? {
      var prev: ListNode? = null
      var current = head

      while (current != null) {
         val next = current.next
         current.next = prev
         prev = current
         current = next
      }

      return prev
   }

   // 找到链表的中点
   val middle = findMiddle(head)

   // 反转后半部分链表
   val secondHalf = reverseList(middle.next)
   val secondHalfHead = secondHalf // 保存用于恢复

   // 比较前半部分和反转后的后半部分
   var isPalindrome = true
   var firstHalf = head
   var secondHalfPtr = secondHalf

   while (secondHalfPtr != null) {
      if (firstHalf?.`val` != secondHalfPtr.`val`) {
         isPalindrome = false
         break
      }
      firstHalf = firstHalf.next
      secondHalfPtr = secondHalfPtr.next
   }

   // 可选：恢复链表原始结构
   // middle.next = reverseList(secondHalfHead)

   return isPalindrome
}
```

**快慢指针+反转解法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)
- 通过反转一半链表避免使用额外的存储空间
- 可以选择性恢复链表的原始结构

### [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

**题目描述：**
给你一个链表的头节点 `head`，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数
`pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：`pos` 不作为参数进行传递。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 `true`。否则，返回 `false`。

**示例：**

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**约束条件：**

- 链表中节点的数目范围是 [0, 10^4]
- -10^5 ≤ Node.val ≤ 10^5
- pos 为 -1 或者链表中的一个有效索引

#### 解题思路

**核心思想：** 使用Floyd的龟兔赛跑算法（快慢指针）。如果链表中存在环，快指针最终会追上慢指针；如果不存在环，快指针会先到达链表末尾。

**算法步骤：**

1. 设置两个指针：慢指针每次移动一步，快指针每次移动两步
2. 如果链表中存在环，快慢指针必然会在环中相遇
3. 如果链表中不存在环，快指针会先到达null

**时间复杂度：** O(n) - 最多遍历链表两次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class HasCycle {
   public boolean hasCycle(ListNode head) {
      if (head == null || head.next == null) return false;

      ListNode slow = head;
      ListNode fast = head;

      while (fast != null && fast.next != null) {
         slow = slow.next;
         fast = fast.next.next;

         if (slow == fast) return true;
      }

      return false;
   }
}
```

**Kotlin版本：**

```kotlin
fun hasCycle(head: ListNode?): Boolean {
   if (head?.next == null) return false

   var slow = head
   var fast = head

   while (fast?.next != null) {
      slow = slow?.next
      fast = fast.next?.next

      if (slow === fast) return true
   }

   return false
}
```

**Floyd算法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)
- 不需要额外的数据结构来记录访问过的节点
- 算法简洁优雅，基于数学证明的正确性

### [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

**题目描述：**
给定一个链表的头节点 `head`，返回链表开始入环的第一个节点。如果链表无环，则返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数
`pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。注意：`pos`
不作为参数进行传递，仅仅是为了标识链表的实际情况。

不允许修改链表。

**示例：**

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。

输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。

输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

**约束条件：**

- 链表中节点的数目范围在范围 [0, 10^4] 内
- -10^5 ≤ Node.val ≤ 10^5
- pos 的值为 -1 或者链表中的一个有效索引

#### 解题思路

**核心思想：** 使用Floyd算法的两阶段方法。第一阶段检测是否有环，第二阶段找到环的入口点。基于数学推导：如果链表有环，从头节点到环入口的距离等于从相遇点继续走到环入口的距离。

**数学证明：**
设定变量：

- `a` = 头节点到环入口的距离
- `b` = 环入口到相遇点的距离
- `c` = 相遇点到环入口的距离
- 环的长度 = `b + c`

当快慢指针相遇时：

- 慢指针走过的距离：`a + b`
- 快指针走过的距离：`a + b + n(b + c)`（比慢指针多走了n圈环）

由于快指针速度是慢指针的2倍：

```
快指针距离 = 2 × 慢指针距离
a + b + n(b + c) = 2(a + b)
n(b + c) = a + b
```

关键推导：

```
n(b + c) - b = a
(n-1)(b + c) + c = a
```

结论：`a = (n-1) × 环长 + c`，意味着从头节点走 `a` 步到达环入口时，从相遇点走的距离恰好是 `(n-1)` 圈环加上 `c`
步，也正好到达环入口。因此两个指针从各自起点同步前进，必然在环入口相遇。

**算法步骤：**

1. 第一阶段：使用快慢指针检测环的存在
2. 如果存在环，第二阶段：将慢指针重置到头节点，快慢指针同步前进
3. 两指针相遇的点就是环的入口

**时间复杂度：** O(n) - 最多遍历链表两次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class DetectCycle {
   public ListNode detectCycle(ListNode head) {
      if (head == null || head.next == null) return null;

      ListNode slow = head;
      ListNode fast = head;

      // 第一阶段：检测是否有环
      while (fast != null && fast.next != null) {
         slow = slow.next;
         fast = fast.next.next;
         if (slow == fast) break;
      }

      // 如果没有环，返回null
      if (fast == null || fast.next == null) return null;

      // 第二阶段：找环的入口
      slow = head;
      while (slow != fast) {
         slow = slow.next;
         fast = fast.next;
      }

      return slow;
   }
}
```

**Kotlin版本：**

```kotlin
fun detectCycle(head: ListNode?): ListNode? {
   if (head?.next == null) return null

   var slow = head
   var fast = head

   // 第一阶段：检测是否有环
   while (fast?.next != null) {
      slow = slow?.next
      fast = fast.next?.next

      if (slow === fast) break
   }

   // 如果fast为空或fast.next为空，说明没有环
   if (fast?.next == null) return null

   // 第二阶段：找环的入口
   slow = head
   while (slow !== fast) {
      slow = slow?.next
      fast = fast?.next
   }

   return slow
}
```

**Floyd算法的优势：**

- 基于严格的数学证明，算法正确性有保证
- 时间复杂度O(n)，空间复杂度O(1)
- 两阶段设计巧妙解决了环检测和入口查找问题

### [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

**题目描述：**
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例：**

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：l1 = [], l2 = []
输出：[]

输入：l1 = [], l2 = [0]
输出：[0]
```

**约束条件：**

- 两个链表的节点数目范围是 [0, 50]
- -100 ≤ Node.val ≤ 100
- l1 和 l2 均按非递减顺序排列

#### 解题思路

**核心思想：** 使用双指针技术，通过比较两个链表当前节点的值，选择较小的节点添加到结果链表中。使用虚拟头节点简化边界处理。

**算法步骤：**

1. 创建虚拟头节点，简化链表操作
2. 使用两个指针分别遍历两个链表
3. 比较当前节点值，将较小的节点连接到结果链表
4. 处理剩余节点

**时间复杂度：** O(m + n) - m和n分别是两个链表的长度
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class MergeTwoLists {
   public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
      ListNode dummy = new ListNode(-1);
      ListNode current = dummy;

      while (list1 != null && list2 != null) {
         if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
         } else {
            current.next = list2;
            list2 = list2.next;
         }
         current = current.next;
      }

      // 连接剩余部分
      current.next = (list1 != null) ? list1 : list2;

      return dummy.next;
   }
}
```

**Kotlin版本：**

```kotlin
fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {
   // 处理边界情况
   if (list1 == null) return list2
   if (list2 == null) return list1

   // 创建哑节点作为新链表的起点
   val dummy = ListNode(0)
   var current = dummy
   var p1 = list1
   var p2 = list2

   // 比较两个链表的节点值，将较小的节点添加到新链表
   while (p1 != null && p2 != null) {
      if (p1.`val` <= p2.`val`) {
         current.next = p1
         p1 = p1.next
      } else {
         current.next = p2
         p2 = p2.next
      }
      current = current.next!!
   }

   // 连接剩余部分
   current.next = p1 ?: p2

   return dummy.next
}
```

**双指针合并解法的优势：**

- 时间复杂度O(m+n)，一次遍历完成合并
- 空间复杂度O(1)，原地操作，重用原始节点
- 保持链表的有序性，逻辑简洁清晰

### [两数相加](https://leetcode.cn/problems/add-two-numbers/)

**题目描述：**
给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807

输入：l1 = [0], l2 = [0]
输出：[0]

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**约束条件：**

- 每个链表中的节点数在范围 [1, 100] 内
- 0 ≤ Node.val ≤ 9
- 题目数据保证列表表示的数字不含前导零

#### 解题思路

**核心思想：** 模拟手工加法过程，从最低位开始逐位相加，处理进位。使用虚拟头节点简化边界处理。

**算法步骤：**

1. 创建虚拟头节点，用于构建结果链表
2. 同时遍历两个链表，逐位相加并处理进位
3. 如果某个链表结束，将其值视为0继续计算
4. 最后检查是否还有进位需要添加新节点

**时间复杂度：** O(max(m, n)) - m和n分别是两个链表的长度
**空间复杂度：** O(max(m, n)) - 结果链表的长度

#### 代码实现

**Java版本：**

```java
public class AddTwoNumbers {
   public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
      ListNode dummy = new ListNode(0);
      ListNode current = dummy;
      int carry = 0;

      while (l1 != null || l2 != null || carry > 0) {
         int val1 = (l1 != null) ? l1.val : 0;
         int val2 = (l2 != null) ? l2.val : 0;

         int sum = val1 + val2 + carry;
         int digit = sum % 10;
         carry = sum / 10;

         current.next = new ListNode(digit);
         current = current.next;

         if (l1 != null) l1 = l1.next;
         if (l2 != null) l2 = l2.next;
      }

      return dummy.next;
   }
}
```

**Kotlin版本：**

```kotlin
fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? {
   val dummy = ListNode(0)
   var current = dummy
   var carry = 0

   var node1 = l1
   var node2 = l2

   while (node1 != null || node2 != null || carry > 0) {
      // 计算当前位的和
      val sum = (node1?.`val` ?: 0) + (node2?.`val` ?: 0) + carry

      // 更新进位值
      carry = sum / 10

      // 创建新节点并移动指针
      current.next = ListNode(sum % 10)
      current = current.next!!

      // 移动输入链表指针
      node1 = node1?.next
      node2 = node2?.next
   }

   return dummy.next
}
```

**逐位相加解法的优势：**

- 直接模拟手工加法，逻辑清晰易懂
- 处理不同长度链表和进位的情况完善
- 时间复杂度最优，只需遍历一次

### [删除链表的倒数第 N 个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

**题目描述：**
给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例：**

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]

输入：head = [1], n = 1
输出：[]

输入：head = [1,2], n = 1
输出：[1]
```

**约束条件：**

- 链表中结点的数目为 sz
- 1 ≤ sz ≤ 30
- 0 ≤ Node.val ≤ 100
- 1 ≤ n ≤ sz

#### 解题思路

**核心思想：** 使用双指针技术（快慢指针）。让快指针先走n步，然后快慢指针同时移动，当快指针到达末尾时，慢指针指向要删除节点的前一个节点。

**算法步骤：**

1. 创建虚拟头节点，处理删除头节点的边界情况
2. 快指针先前进n+1步（指向要删除节点的后一个节点）
3. 快慢指针同时前进，直到快指针到达末尾
4. 此时慢指针指向要删除节点的前驱，执行删除操作

**时间复杂度：** O(L) - L是链表长度，只需遍历一次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class RemoveNthFromEnd {
   public ListNode removeNthFromEnd(ListNode head, int n) {
      ListNode dummy = new ListNode(0);
      dummy.next = head;

      ListNode prev = findFromEnd(dummy, n + 1);
      prev.next = prev.next.next;

      return dummy.next;
   }

   private ListNode findFromEnd(ListNode head, int k) {
      ListNode fast = head;
      ListNode slow = head;

      // 快指针先前进k步
      for (int i = 0; i < k; i++) {
         fast = fast.next;
      }

      // 快慢指针同时前进，当快指针到达末尾时，慢指针指向倒数第k个节点
      while (fast != null) {
         slow = slow.next;
         fast = fast.next;
      }

      return slow;
   }
}
```

**Kotlin版本：**

```kotlin
fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {
   val dummy = ListNode(-1).apply { next = head }

   fun findFromEnd(head: ListNode, k: Int): ListNode {
      var fast = head as ListNode?
      var slow = head

      // 快指针先前进k步
      repeat(k) {
         fast = fast!!.next
      }

      // 快慢指针同时前进，当快指针到达末尾时，慢指针指向倒数第k个节点
      while (fast != null) {
         slow = slow.next!!
         fast = fast.next
      }

      return slow
   }

   // 找到倒数第n+1个节点（要删除节点的前驱）
   val prev = findFromEnd(dummy, n + 1)

   // 删除倒数第n个节点
   prev.next = prev.next?.next

   return dummy.next
}
```

**双指针解法的优势：**

- 只需遍历链表一次，时间复杂度O(n)
- 不需要预先计算链表长度
- 使用虚拟头节点优雅处理边界情况

### [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

**题目描述：**
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改链表节点值的情况下完成本题（即，只能进行节点交换）。

**示例：**

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]

输入：head = []
输出：[]

输入：head = [1]
输出：[1]
```

#### 解题思路

**核心思想：** 使用递归或迭代方法，每次处理两个相邻节点的交换。

**时间复杂度：** O(n) - 遍历整个链表
**空间复杂度：** O(1) - 迭代版本，O(n) - 递归版本

#### 代码实现

**Java版本：**

```java
public class SwapPairs {
   public ListNode swapPairs(ListNode head) {
      // 递归终止条件：没有节点或只有一个节点
      if (head == null || head.next == null) return head;

      ListNode firstNode = head;
      ListNode secondNode = head.next;
      ListNode remainingNodes = secondNode.next;

      // 递归处理后续节点
      firstNode.next = swapPairs(remainingNodes);

      // 交换当前两个节点
      secondNode.next = firstNode;

      return secondNode;
   }
}
```

**Kotlin版本：**

```kotlin
fun swapPairs(head: ListNode?): ListNode? {
   // 递归终止条件：没有节点或只有一个节点
   if (head?.next == null) return head

   val firstNode = head
   val secondNode = firstNode.next!!
   val remainingNodes = secondNode.next

   // 递归处理后续节点
   firstNode.next = swapPairs(remainingNodes)

   // 交换当前两个节点
   secondNode.next = firstNode

   return secondNode
}
```

### [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

**题目描述：**
给你链表的头节点 `head`，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例：**

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]

输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**约束条件：**

- 链表中的节点数目为 n
- 1 ≤ k ≤ n ≤ 5000
- 0 ≤ Node.val ≤ 1000

#### 解题思路

**核心思想：** 分组处理链表，对每k个节点进行局部反转。需要先计算链表长度，然后对每组k个节点执行反转操作，最后连接各组。

**算法步骤：**

1. 计算链表总长度，确定需要反转的组数
2. 对每组k个节点进行反转操作
3. 正确连接反转后的各组和剩余节点
4. 处理不足k个节点的剩余部分（保持原序）

**时间复杂度：** O(n) - 每个节点最多被访问两次
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class ReverseKGroup {
   public ListNode reverseKGroup(ListNode head, int k) {
      if (head == null || k == 1) return head;

      ListNode dummy = new ListNode(0);
      dummy.next = head;

      int totalLength = getLength(head);
      int groupCount = totalLength / k;

      ListNode prevGroupTail = dummy;
      ListNode currentGroupHead = head;

      // 进行groupCount次反转  
      for (int i = 0; i < groupCount; i++) {
         ListNode nextGroupHead = getKthNode(currentGroupHead, k).next;

         // 反转当前组，返回反转后的新头节点  
         ListNode reversedGroupHead = reverseKNodes(currentGroupHead, k);

         // 连接反转后的组  
         prevGroupTail.next = reversedGroupHead;
         currentGroupHead.next = nextGroupHead;

         // 更新指针，准备处理下一组  
         prevGroupTail = currentGroupHead;
         currentGroupHead = nextGroupHead;
      }

      return dummy.next;
   }

   private int getLength(ListNode head) {
      int length = 0;
      while (head != null) {
         head = head.next;
         length++;
      }
      return length;
   }

   private ListNode getKthNode(ListNode head, int k) {
      ListNode current = head;
      for (int i = 1; i < k && current != null; i++) {
         current = current.next;
      }
      return current;
   }

   private ListNode reverseKNodes(ListNode head, int k) {
      ListNode prev = null;
      ListNode current = head;

      for (int i = 0; i < k && current != null; i++) {
         ListNode next = current.next;
         current.next = prev;
         prev = current;
         current = next;
      }

      return prev; // 返回反转后的头节点  
   }
}
```

**Kotlin版本：**

```kotlin
fun reverseKGroup(head: ListNode?, k: Int): ListNode? {
   if (head == null || k == 1) return head

   fun getLength(): Int {
      var length = 0
      var current = head
      while (current != null) {
         current = current.next
         length++
      }
      return length
   }

   fun getKthNode(head: ListNode, k: Int): ListNode {
      var current = head
      repeat(k - 1) {
         current = current.next!!
      }
      return current
   }

   fun reverseKNodes(head: ListNode, k: Int): ListNode {
      var prev: ListNode? = null
      var current: ListNode? = head

      repeat(k) {
         val next = current!!.next
         current.next = prev
         prev = current
         current = next
      }

      return prev!! // 返回反转后的头节点  
   }

   val dummy = ListNode(0)
   dummy.next = head

   val totalLength = getLength()
   val groupCount = totalLength / k

   var prevGroupTail = dummy
   var currentGroupHead = head

   // 进行groupCount次反转  
   repeat(groupCount) {
      val nextGroupHead = getKthNode(currentGroupHead!!, k).next

      val reversedGroupHead = reverseKNodes(currentGroupHead, k)

      // 连接反转后的组  
      prevGroupTail.next = reversedGroupHead
      currentGroupHead.next = nextGroupHead

      // 更新指针，准备处理下一组  
      prevGroupTail = currentGroupHead
      currentGroupHead = nextGroupHead
   }

   return dummy.next
}
```

**分组反转解法的优势：**

- 时间复杂度O(n)，每个节点最多被访问两次
- 空间复杂度O(1)，原地操作
- 正确处理不足k个节点的剩余部分

### [复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

**题目描述：**
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 `random`，该指针可以指向链表中的任何节点或空节点。

构造这个链表的深拷贝。深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和
`random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。

**示例：**

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]

输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**约束条件：**

- 0 ≤ n ≤ 1000
- -10^4 ≤ Node.val ≤ 10^4
- Node.random 为 null 或指向链表中的节点

#### 解题思路

**核心思想：** 使用三步法：先在每个原节点后插入复制节点形成交错链表，然后设置复制节点的random指针，最后分离两个链表。

**算法步骤：**

1. 在每个原节点后创建对应的复制节点
2. 设置复制节点的random指针（利用原节点的random关系）
3. 分离原链表和复制链表，恢复原链表结构

**时间复杂度：** O(n) - 需要遍历链表三次
**空间复杂度：** O(1) - 不考虑输出空间，只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class CopyRandomList {
   public Node copyRandomList(Node head) {
      if (head == null) return null;

      createCopyNodes(head);
      assignRandomPointers(head);
      return separateLists(head);
   }

   private void createCopyNodes(Node head) {
      Node current = head;
      while (current != null) {
         Node copyNode = new Node(current.val);
         copyNode.next = current.next;
         current.next = copyNode;
         current = copyNode.next;
      }
   }

   private void assignRandomPointers(Node head) {
      Node current = head;
      while (current != null) {
         if (current.random != null) {
            current.next.random = current.random.next;
         }
         current = current.next.next;
      }
   }

   private Node separateLists(Node head) {
      Node copyHead = head.next;
      Node current = head;
      while (current != null && current.next != null) {
         Node temp = current.next;
         current.next = current.next.next;
         current = temp;
      }
      return copyHead;
   }
}
```

**Kotlin版本：**

```kotlin
fun copyRandomList(head: Node?): Node? {
   head ?: return null

   fun createCopyNodes() {
      var current: Node? = head
      while (current != null) {
         val copyNode = Node(current.`val`)
         copyNode.next = current.next
         current.next = copyNode
         current = copyNode.next
      }
   }
   fun assignRandomPointers() {
      var current: Node? = head
      while (current != null) {
         current.next?.random = current.random?.next
         current = current.next?.next
      }
   }
   fun separateLists(): Node? {
      val copyHead = head.next
      var current: Node? = head
      while (current?.next != null) {
         val temp = current.next
         current.next = current.next?.next
         current = temp
      }
      return copyHead
   }

   createCopyNodes()
   assignRandomPointers()
   return separateLists()
}
```

**三步复制解法的优势：**

- 空间复杂度O(1)，不需要额外的哈希表
- 通过交错链表巧妙处理random指针复制
- 三步操作逻辑清晰，易于理解和实现

### [排序链表](https://leetcode.cn/problems/sort-list/)

**题目描述：**
给你链表的头结点 `head`，请将其按升序排列并返回排序后的链表。

**示例：**

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]

输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]

输入：head = []
输出：[]
```

**约束条件：**

- 链表中节点的数目在范围 [0, 5 × 10^4] 内
- -10^5 ≤ Node.val ≤ 10^5

**进阶：** 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

#### 解题思路

**核心思想：** 使用归并排序算法。通过快慢指针找到链表中点，递归地对两半部分排序，然后合并两个有序链表。

**算法步骤：**

1. 使用快慢指针找到链表的中点并分割
2. 递归地对左右两部分进行排序
3. 合并两个已排序的链表
4. 递归终止条件：链表为空或只有一个节点

**时间复杂度：** O(n log n) - 标准归并排序时间复杂度
**空间复杂度：** O(log n) - 递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class SortList {
   public ListNode sortList(ListNode head) {
      if (head == null || head.next == null) return head;

      ListNode middleNode = findMiddleAndSplit(head);
      ListNode leftSorted = sortList(head);
      ListNode rightSorted = sortList(middleNode);

      return mergeTwoSortedLists(leftSorted, rightSorted);
   }

   private ListNode findMiddleAndSplit(ListNode head) {
      ListNode slowPointer = head;
      ListNode fastPointer = head.next;

      while (fastPointer != null && fastPointer.next != null) {
         slowPointer = slowPointer.next;
         fastPointer = fastPointer.next.next;
      }

      ListNode middleNode = slowPointer.next;
      slowPointer.next = null; // 分割链表
      return middleNode;
   }

   private ListNode mergeTwoSortedLists(ListNode firstList, ListNode secondList) {
      ListNode dummyHead = new ListNode(0);
      ListNode currentNode = dummyHead;

      while (firstList != null && secondList != null) {
         if (firstList.val <= secondList.val) {
            currentNode.next = firstList;
            firstList = firstList.next;
         } else {
            currentNode.next = secondList;
            secondList = secondList.next;
         }
         currentNode = currentNode.next;
      }

      currentNode.next = (firstList != null) ? firstList : secondList;
      return dummyHead.next;
   }
}
```

**Kotlin版本：**

```kotlin
fun sortList(head: ListNode?): ListNode? {
   if (head?.next == null) return head

   fun findMiddleAndSplit(head: ListNode): ListNode {
      var slowPointer = head
      var fastPointer = head.next

      while (fastPointer?.next != null) {
         slowPointer = slowPointer.next!!
         fastPointer = fastPointer.next?.next
      }

      val middleNode = slowPointer.next!!
      slowPointer.next = null // 分割链表
      return middleNode
   }

   fun mergeTwoSortedLists(firstList: ListNode?, secondList: ListNode?): ListNode? {
      val dummyHead = ListNode(0)
      var currentNode = dummyHead
      var leftPointer = firstList
      var rightPointer = secondList

      while (leftPointer != null && rightPointer != null) {
         if (leftPointer.`val` <= rightPointer.`val`) {
            currentNode.next = leftPointer
            leftPointer = leftPointer.next
         } else {
            currentNode.next = rightPointer
            rightPointer = rightPointer.next
         }
         currentNode = currentNode.next!!
      }

      currentNode.next = leftPointer ?: rightPointer
      return dummyHead.next
   }

   val middleNode = findMiddleAndSplit(head)
   val leftSorted = sortList(head)
   val rightSorted = sortList(middleNode)

   return mergeTwoSortedLists(leftSorted, rightSorted)
}
```

**归并排序解法的优势：**

- 时间复杂度O(n log n)，性能稳定
- 适合链表结构，不需要随机访问
- 分治思想，逻辑清晰易于实现

### [合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

**题目描述：**
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到：
1->1->2->3->4->4->5->6

输入：lists = []
输出：[]

输入：lists = [[]]
输出：[]
```

**约束条件：**

- k == lists.length
- 0 ≤ k ≤ 10^4
- 0 ≤ lists[i].length ≤ 500
- -10^4 ≤ lists[i][j] ≤ 10^4
- lists[i] 按升序排列
- lists[i].length 的总和不超过 10^4

#### 解题思路

**核心思想：** 使用优先队列（最小堆）来维护所有链表的当前最小节点。每次从堆中取出最小节点添加到结果链表中，并将该节点的下一个节点加入堆中。

**算法步骤：**

1. 将所有链表的头节点加入优先队列
2. 不断从队列中取出最小节点，添加到结果链表
3. 如果取出的节点有后继节点，将后继节点加入队列
4. 重复直到队列为空

**时间复杂度：** O(N log k) - N是所有节点总数，k是链表个数
**空间复杂度：** O(k) - 优先队列最多存储k个节点

#### 代码实现

**Java版本：**

```java
public class MergeKLists {
   public ListNode mergeKLists(ListNode[] sortedLists) {
      if (sortedLists.length == 0) return null;

      PriorityQueue<ListNode> minHeap = new PriorityQueue<>((firstNode, secondNode) -> firstNode.val - secondNode.val);

      // 将所有链表的头节点加入最小堆
      for (ListNode listHead : sortedLists) {
         if (listHead != null) minHeap.offer(listHead);
      }

      ListNode dummyHead = new ListNode(0);
      ListNode currentNode = dummyHead;

      // 不断从堆中取出最小节点构建结果链表
      while (!minHeap.isEmpty()) {
         ListNode smallestNode = minHeap.poll();
         currentNode.next = smallestNode;
         currentNode = currentNode.next;

         // 如果取出的节点有后继节点，将其加入堆中
         if (smallestNode.next != null) {
            minHeap.offer(smallestNode.next);
         }
      }

      return dummyHead.next;
   }
}
```

**Kotlin版本：**

```kotlin
fun mergeKLists(sortedLists: Array<ListNode?>): ListNode? {
   if (sortedLists.isEmpty()) return null

   val dummyHead = ListNode(0)
   var currentNode = dummyHead

   val minHeap = PriorityQueue(compareBy<ListNode> { it.`val` })

   // 将所有链表的头节点加入最小堆
   sortedLists.filterNotNull().forEach { listHead ->
      minHeap.add(listHead)
   }

   // 不断从堆中取出最小节点构建结果链表
   while (minHeap.isNotEmpty()) {
      val smallestNode = minHeap.poll()
      currentNode.next = smallestNode
      currentNode = smallestNode

      // 如果取出的节点有后继节点，将其加入堆中
      smallestNode.next?.let { nextNode ->
         minHeap.add(nextNode)
      }
   }

   return dummyHead.next
}
```

**优先队列解法的优势：**

- 时间复杂度O(N log k)，比逐个合并更高效
- 始终选择当前最小的节点，保证结果有序
- 适用于大量链表的合并场景

### [LRU缓存](https://leetcode.cn/problems/lru-cache/)

**题目描述：**
请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以正整数作为容量 capacity 初始化 LRU 缓存
- `int get(int key)` 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1
- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**约束条件：**

- 1 ≤ capacity ≤ 3000
- 0 ≤ key ≤ 10^4
- 0 ≤ value ≤ 10^5
- 最多调用 2 × 10^5 次 get 和 put

#### 解题思路

**核心思想：** 使用哈希表 + 双向链表的组合数据结构。哈希表提供O(1)的查找时间，双向链表维护访问顺序，支持O(1)的插入和删除。

**算法步骤：**

1. 哈希表存储key到链表节点的映射
2. 双向链表维护访问顺序（头部最新，尾部最旧）
3. get操作：查找节点并移动到头部
4. put操作：更新或插入节点，超出容量时删除尾部节点

**时间复杂度：** O(1) - get和put操作都是常数时间
**空间复杂度：** O(capacity) - 存储容量限制的节点

#### 代码实现

**Java版本：**

```java
class LRUCache {
   /**
    * 缓存容量
    */
   private final int cacheCapacity;

   /**
    * 哈希表，用于O(1)时间查找节点
    */
   private final Map<Integer, CacheNode> keyToNodeMap;

   /**
    * 哨兵节点，作为双向链表的头部标记
    */
   private final CacheNode sentinelHead = new CacheNode();

   /**
    * 哨兵节点，作为双向链表的尾部标记
    */
   private final CacheNode sentinelTail = new CacheNode();

   /**
    * 双向链表节点类
    */
   static class CacheNode {
      int key, value;
      CacheNode prev, next;

      CacheNode() {
      }

      CacheNode(int key, int value) {
         this.key = key;
         this.value = value;
      }
   }

   public LRUCache(int capacity) {
      this.cacheCapacity = capacity;
      this.keyToNodeMap = new HashMap<>();

      // 初始化哨兵节点，形成空的双向链表
      sentinelHead.next = sentinelTail;
      sentinelTail.prev = sentinelHead;
   }

   /**
    * 获取缓存中key对应的值
    * @param key 要查询的键
    * @return 如果键存在则返回对应的值，否则返回-1
    */
   public int get(int key) {
      CacheNode targetNode = keyToNodeMap.get(key);
      if (targetNode == null) return -1;

      // 访问节点后，将其移动到链表头部（表示最近使用）
      moveToHead(targetNode);
      return targetNode.value;
   }

   /**
    * 插入或更新缓存
    * @param key 键
    * @param value 值
    */
   public void put(int key, int value) {
      CacheNode existingNode = keyToNodeMap.get(key);

      if (existingNode != null) {
         // 键已存在，更新值并移至链表头部
         existingNode.value = value;
         moveToHead(existingNode);
      } else {
         // 键不存在，创建新节点
         CacheNode newNode = new CacheNode(key, value);
         keyToNodeMap.put(key, newNode);
         addToHead(newNode);

         // 如果缓存已满，移除最久未使用的节点（链表尾部）
         if (keyToNodeMap.size() > cacheCapacity) {
            CacheNode oldestNode = removeTail();
            keyToNodeMap.remove(oldestNode.key);
         }
      }
   }

   /**
    * 将节点添加到链表头部（最近使用位置）
    */
   private void addToHead(CacheNode node) {
      node.prev = sentinelHead;
      node.next = sentinelHead.next;

      sentinelHead.next.prev = node;
      sentinelHead.next = node;
   }

   /**
    * 从链表中移除指定节点
    */
   private void removeNode(CacheNode node) {
      node.prev.next = node.next;
      node.next.prev = node.prev;
   }

   /**
    * 将节点移动到链表头部
    */
   private void moveToHead(CacheNode node) {
      removeNode(node);
      addToHead(node);
   }

   /**
    * 移除并返回链表尾部节点（最久未使用的节点）
    */
   private CacheNode removeTail() {
      CacheNode oldestNode = sentinelTail.prev;
      removeNode(oldestNode);
      return oldestNode;
   }
}
```

**Kotlin版本：**

```kotlin
class LRUCache(private val cacheCapacity: Int) {

   /**
    * 哈希表，用于O(1)时间查找节点
    */
   private val keyToNodeMap = mutableMapOf<Int, CacheNode>()

   /**
    * 哨兵节点，作为双向链表的头部标记
    */
   private val sentinelHead = CacheNode()

   /**
    * 哨兵节点，作为双向链表的尾部标记
    */
   private val sentinelTail = CacheNode()

   /**
    * 双向链表节点类
    */
   class CacheNode(val key: Int = 0, var value: Int = 0) {
      var prev: CacheNode? = null
      var next: CacheNode? = null
   }

   init {
      // 初始化哨兵节点，形成空的双向链表
      sentinelHead.next = sentinelTail
      sentinelTail.prev = sentinelHead
   }

   /**
    * 获取缓存中key对应的值
    * @param key 要查询的键
    * @return 如果键存在则返回对应的值，否则返回-1
    */
   fun get(key: Int): Int {
      val targetNode = keyToNodeMap[key] ?: return -1

      // 访问节点后，将其移动到链表头部（表示最近使用）
      moveToHead(targetNode)
      return targetNode.value
   }

   /**
    * 插入或更新缓存
    * @param key 键
    * @param value 值
    */
   fun put(key: Int, value: Int) {
      val existingNode = keyToNodeMap[key]

      if (existingNode != null) {
         // 键已存在，更新值并移至链表头部
         existingNode.value = value
         moveToHead(existingNode)
      } else {
         // 键不存在，创建新节点
         val newNode = CacheNode(key, value)
         keyToNodeMap[key] = newNode
         addToHead(newNode)

         // 如果缓存已满，移除最久未使用的节点（链表尾部）
         if (keyToNodeMap.size > cacheCapacity) {
            val oldestNode = removeTail()
            keyToNodeMap.remove(oldestNode.key)
         }
      }
   }

   /**
    * 将节点添加到链表头部（最近使用位置）
    */
   private fun addToHead(node: CacheNode) {
      node.prev = sentinelHead
      node.next = sentinelHead.next

      sentinelHead.next?.prev = node
      sentinelHead.next = node
   }

   /**
    * 从链表中移除指定节点
    */
   private fun removeNode(node: CacheNode) {
      node.prev?.next = node.next
      node.next?.prev = node.prev
   }

   /**
    * 将节点移动到链表头部
    */
   private fun moveToHead(node: CacheNode) {
      removeNode(node)
      addToHead(node)
   }

   /**
    * 移除并返回链表尾部节点（最久未使用的节点）
    */
   private fun removeTail(): CacheNode {
      val oldestNode = sentinelTail.prev!!
      removeNode(oldestNode)
      return oldestNode
   }
}
```

**双向链表+哈希表解法的优势：**

- 时间复杂度O(1)：get和put操作都是常数时间
- 空间复杂度O(capacity)：只存储容量限制的节点
- 数据结构巧妙结合：哈希表提供快速查找，双向链表维护访问顺序

## 二叉树

### [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

**题目描述：**
给定一个二叉树的根节点 `root`，返回它的中序遍历结果。

**示例：**

```
输入：root = [1,null,2,3]
输出：[1,3,2]

输入：root = []
输出：[]

输入：root = [1]
输出：[1]
```

**约束条件：**

- 树中节点数目在范围 [0, 100] 内
- -100 ≤ Node.val ≤ 100

#### 解题思路

**核心思想：** 使用递归方法实现中序遍历。中序遍历的顺序是：左子树 → 根节点 → 右子树。

**算法步骤：**

1. 如果当前节点为空，直接返回
2. 递归遍历左子树
3. 访问当前节点，将值添加到结果列表
4. 递归遍历右子树

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class InorderTraversal {
   public List<Integer> inorderTraversal(TreeNode root) {
      List<Integer> result = new ArrayList<>();
      inorderHelper(root, result);
      return result;
   }

   private void inorderHelper(TreeNode node, List<Integer> result) {
      if (node == null) return;

      // 递归遍历左子树
      inorderHelper(node.left, result);
      // 访问当前节点
      result.add(node.val);
      // 递归遍历右子树
      inorderHelper(node.right, result);
   }
}
```

**Kotlin版本：**

```kotlin
fun inorderTraversal(root: TreeNode?): List<Int> {
   val result = mutableListOf<Int>()

   fun inorderHelper(node: TreeNode?) {
      if (node == null) return

      // 递归遍历左子树
      inorderHelper(node.left)
      // 访问当前节点
      result.add(node.`val`)
      // 递归遍历右子树
      inorderHelper(node.right)
   }

   inorderHelper(root)
   return result
}
```

**递归遍历解法的优势：**

- 代码简洁清晰，符合中序遍历的定义
- 递归结构天然适合树的遍历操作
- 易于理解和实现，逻辑直观

### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

**题目描述：**
给定一个二叉树的根节点 `root`，返回其最大深度。二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例：**

```
输入：root = [3,9,20,null,null,15,7]
输出：3

输入：root = [1,null,2]
输出：2

输入：root = []
输出：0
```

**约束条件：**

- 树中节点的数量在 [0, 10⁴] 范围内
- -100 ≤ Node.val ≤ 100

#### 解题思路

**核心思想：** 使用递归方法计算二叉树的最大深度。每个节点的最大深度等于其左右子树的最大深度的较大值加1。

**算法步骤：**

1. 如果当前节点为空，返回深度0
2. 递归计算左子树的最大深度
3. 递归计算右子树的最大深度
4. 返回左右子树最大深度的较大值加1

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class MaxDepth {
   public int maxDepth(TreeNode root) {
      if (root == null) return 0;

      int leftDepth = maxDepth(root.left);
      int rightDepth = maxDepth(root.right);

      return Math.max(leftDepth, rightDepth) + 1;
   }
}
```

**Kotlin版本：**

```kotlin
fun maxDepth(root: TreeNode?): Int {
   if (root == null) return 0

   val leftDepth = maxDepth(root.left)
   val rightDepth = maxDepth(root.right)

   return maxOf(leftDepth, rightDepth) + 1
}
```

**递归解法的优势：**

- 算法逻辑简洁直观，符合数学定义
- 代码实现简单，易于理解和维护
- 自然地处理了空树和单节点树的边界情况

### [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

**题目描述：**
给定一个二叉树的根节点 `root`，翻转这棵二叉树，并返回其根节点。翻转二叉树就是将二叉树的所有节点的左右子树互换。

**示例：**

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]

输入：root = [2,1,3]
输出：[2,3,1]

输入：root = []
输出：[]
```

**约束条件：**

- 树中节点数目范围在 [0, 100] 内
- -100 ≤ Node.val ≤ 100

#### 解题思路

**核心思想：** 使用递归方法翻转二叉树。对于每个节点，先递归翻转其左右子树，然后交换左右子树的位置。

**算法步骤：**

1. 如果当前节点为空，直接返回null
2. 递归翻转左子树
3. 递归翻转右子树
4. 交换当前节点的左右子树
5. 返回当前节点

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class InvertTree {
   public TreeNode invertTree(TreeNode root) {
      if (root == null) return null;

      TreeNode leftSubtree = invertTree(root.left);
      TreeNode rightSubtree = invertTree(root.right);

      root.left = rightSubtree;
      root.right = leftSubtree;

      return root;
   }
}
```

**Kotlin版本：**

```kotlin
fun invertTree(root: TreeNode?): TreeNode? {
   if (root == null) return null

   val leftSubtree = invertTree(root.left)
   val rightSubtree = invertTree(root.right)

   root.left = rightSubtree
   root.right = leftSubtree

   return root
}
```

**递归解法的优势：**

- 思路清晰，直接按照翻转的定义实现
- 代码简洁，易于理解和维护
- 天然处理了各种边界情况（空树、单节点树等）

### [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

**题目描述：**
给定一个二叉树的根节点 `root`，检查它是否轴对称。一个二叉树是轴对称的，当且仅当它的左子树和右子树互为镜像。

**示例：**

```
输入：root = [1,2,2,3,4,4,3]
输出：true

输入：root = [1,2,2,null,3,null,3]
输出：false

输入：root = []
输出：true
```

**约束条件：**

- 树中节点数目在范围 [1, 1000] 内
- -100 ≤ Node.val ≤ 100

#### 解题思路

**核心思想：** 使用递归方法判断二叉树是否对称。问题转化为判断左右子树是否互为镜像，即左子树的左节点与右子树的右节点相等，左子树的右节点与右子树的左节点相等。

**算法步骤：**

1. 如果根节点为空，返回true（空树是对称的）
2. 调用辅助函数比较左右子树是否镜像对称
3. 在辅助函数中：
   - 如果两个节点都为空，返回true
   - 如果只有一个节点为空或节点值不等，返回false
   - 递归检查左节点的左子树与右节点的右子树，以及左节点的右子树与右节点的左子树

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class IsSymmetric {
   public boolean isSymmetric(TreeNode root) {
      if (root == null) return true;
      return isMirror(root.left, root.right);
   }

   private boolean isMirror(TreeNode leftNode, TreeNode rightNode) {
      if (leftNode == null && rightNode == null) return true;
      if (leftNode == null || rightNode == null) return false;

      return leftNode.val == rightNode.val
              && isMirror(leftNode.left, rightNode.right)
              && isMirror(leftNode.right, rightNode.left);
   }
}
```

**Kotlin版本：**

```kotlin
fun isSymmetric(root: TreeNode?): Boolean {
   if (root == null) return true
   return isMirror(root.left, root.right)
}

private fun isMirror(leftNode: TreeNode?, rightNode: TreeNode?): Boolean {
   if (leftNode == null && rightNode == null) return true
   if (leftNode == null || rightNode == null) return false

   return leftNode.`val` == rightNode.`val`
           && isMirror(leftNode.left, rightNode.right)
           && isMirror(leftNode.right, rightNode.left)
}
```

**递归解法的优势：**

- 逻辑清晰，直接按照对称的数学定义实现
- 通过辅助函数将复杂问题分解为简单的镜像比较
- 代码结构简洁，易于理解和验证正确性

### [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

**题目描述：**
给定一棵二叉树的根节点 `root`，返回该树的直径。二叉树的 **直径**
是指树中任意两个节点之间最长路径的长度。这条路径可能穿过也可能不穿过根节点。两节点之间的路径长度是以它们之间边的数目表示。

**示例：**

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。

输入：root = [1,2]
输出：1

输入：root = []
输出：0
```

**约束条件：**

- 树中节点数目在范围 [1, 10⁴] 内
- -100 ≤ Node.val ≤ 100

#### 解题思路

**核心思想：** 使用递归方法计算二叉树的直径。对于每个节点，其直径等于通过该节点的最长路径，即左子树的最大深度加上右子树的最大深度。在递归计算深度的过程中，同时维护全局最大直径。

**算法步骤：**

1. 初始化全局变量记录最大直径
2. 定义递归函数计算节点的最大深度
3. 对于每个节点：
   - 如果节点为空，返回深度0
   - 递归计算左子树和右子树的最大深度
   - 更新全局最大直径为当前直径和左右子树深度之和的最大值
   - 返回当前节点的最大深度（左右子树最大深度的较大值加1）
4. 返回全局最大直径

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class DiameterOfBinaryTree {
   private int maxDiameter = 0;

   public int diameterOfBinaryTree(TreeNode root) {
      calculateDepth(root);
      return maxDiameter;
   }

   private int calculateDepth(TreeNode node) {
      if (node == null) return 0;

      int leftDepth = calculateDepth(node.left);
      int rightDepth = calculateDepth(node.right);

      // 更新最大直径
      maxDiameter = Math.max(maxDiameter, leftDepth + rightDepth);

      // 返回当前节点的最大深度
      return Math.max(leftDepth, rightDepth) + 1;
   }
}
```

**Kotlin版本：**

```kotlin
fun diameterOfBinaryTree(root: TreeNode?): Int {
   if (root == null) return 0

   var maxDiameter = 0

   fun calculateDepth(node: TreeNode?): Int {
      if (node == null) return 0

      val leftDepth = calculateDepth(node.left)
      val rightDepth = calculateDepth(node.right)

      // 更新最大直径
      maxDiameter = maxOf(maxDiameter, leftDepth + rightDepth)

      // 返回当前节点的最大深度
      return maxOf(leftDepth, rightDepth) + 1
   }

   calculateDepth(root)
   return maxDiameter
}
```

**递归解法的优势：**

- 一次遍历即可完成直径计算，效率高
- 巧妙地将直径计算融入深度计算过程中
- 代码简洁，逻辑清晰，易于理解和实现

### [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

**题目描述：**
给定一个二叉树的根节点 `root`，返回其按层序遍历得到的节点值。（即逐层地，从左到右访问所有节点）

**示例：**

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]

输入：root = [1]
输出：[[1]]

输入：root = []
输出：[]
```

**约束条件：**

- 树中节点数目在范围 [0, 2000] 内
- -1000 ≤ Node.val ≤ 1000

#### 解题思路

**核心思想：** 使用队列实现广度优先搜索（BFS），逐层遍历二叉树。通过记录每层的节点数量来分层处理。

**算法步骤：**

1. 如果根节点为空，返回空列表
2. 初始化队列并将根节点入队
3. 当队列不为空时：
   - 记录当前层的节点数量
   - 创建当前层的结果列表
   - 处理当前层的所有节点：将节点值加入结果，子节点入队
   - 将当前层结果加入最终结果
4. 返回分层结果

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(w) - w是树的最大宽度，队列最多存储一层的节点

#### 代码实现

**Java版本：**

```java
public class LevelOrder {
   public List<List<Integer>> levelOrder(TreeNode root) {
      if (root == null) return Collections.emptyList();

      ArrayDeque<TreeNode> queue = new ArrayDeque<>();
      List<List<Integer>> result = new ArrayList<>();

      queue.add(root);

      while (!queue.isEmpty()) {
         int currentLevelSize = queue.size();
         List<Integer> currentLevel = new ArrayList<>();

         while (currentLevelSize-- > 0) {
            TreeNode currentNode = queue.pollFirst();
            currentLevel.add(currentNode.val);

            if (currentNode.left != null) queue.addLast(currentNode.left);
            if (currentNode.right != null) queue.addLast(currentNode.right);
         }
         result.add(currentLevel);
      }
      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun levelOrder(root: TreeNode?): List<List<Int>> {
   if (root == null) return emptyList()

   val queue = ArrayDeque<TreeNode>().apply { addLast(root) }
   val result = mutableListOf<List<Int>>()

   while (queue.isNotEmpty()) {
      val currentLevel = mutableListOf<Int>()
      val currentLevelSize = queue.size

      repeat(currentLevelSize) {
         val currentNode = queue.removeFirst()
         currentLevel.add(currentNode.`val`)

         currentNode.left?.let { queue.addLast(it) }
         currentNode.right?.let { queue.addLast(it) }
      }
      result.add(currentLevel)
   }

   return result
}
```

**BFS解法的优势：**

- 自然地按层处理节点，符合层序遍历的定义
- 队列数据结构保证了节点访问的顺序性
- 代码逻辑清晰，易于理解和实现

### [将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

**题目描述：**
给定一个有序整数数组 `nums`，将其转换为一棵高度平衡的二叉搜索树。高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。

**示例：**

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被接受

输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡BST

输入：nums = []
输出：[]
```

**约束条件：**

- 1 ≤ nums.length ≤ 10⁴
- -10⁴ ≤ nums[i] ≤ 10⁴
- nums 按严格递增顺序排列

#### 解题思路

**核心思想：** 使用分治法递归构建平衡二叉搜索树。选择数组的中点作为根节点，左半部分构建左子树，右半部分构建右子树，确保树的平衡性。

**算法步骤：**

1. 如果数组为空或起始索引大于结束索引，返回null
2. 计算中点索引，避免整数溢出
3. 创建根节点，使用中点元素值
4. 递归构建左子树（使用左半部分数组）
5. 递归构建右子树（使用右半部分数组）
6. 返回根节点

**时间复杂度：** O(n) - 每个数组元素访问一次
**空间复杂度：** O(log n) - 递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class SortedArrayToBST {
   public TreeNode sortedArrayToBST(int[] nums) {
      return buildTree(nums, 0, nums.length - 1);
   }

   private TreeNode buildTree(int[] nums, int leftIndex, int rightIndex) {
      if (leftIndex > rightIndex) return null;

      int midIndex = leftIndex + (rightIndex - leftIndex) / 2;
      TreeNode root = new TreeNode(nums[midIndex]);

      root.left = buildTree(nums, leftIndex, midIndex - 1);
      root.right = buildTree(nums, midIndex + 1, rightIndex);

      return root;
   }
}
```

**Kotlin版本：**

```kotlin
fun sortedArrayToBST(nums: IntArray): TreeNode? {
   if (nums.isEmpty()) return null

   fun buildTree(startIndex: Int, endIndex: Int): TreeNode? {
      if (startIndex > endIndex) return null

      val midIndex = startIndex + (endIndex - startIndex) / 2

      return TreeNode(nums[midIndex]).apply {
         left = buildTree(startIndex, midIndex - 1)
         right = buildTree(midIndex + 1, endIndex)
      }
   }

   return buildTree(0, nums.lastIndex)
}
```

**分治递归解法的优势：**

- 自动保证生成的BST是高度平衡的
- 利用有序数组的特性，无需额外排序
- 递归结构清晰，易于理解和实现

### [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

**题目描述：**
给定一个二叉树的根节点 `root`，判断其是否是一个有效的二叉搜索树。有效二叉搜索树定义如下：节点的左子树只包含小于当前节点的数，节点的右子树只包含大于当前节点的数，所有左子树和右子树自身必须也是二叉搜索树。

**示例：**

```
输入：root = [2,1,3]
输出：true

输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。

输入：root = []
输出：true
```

**约束条件：**

- 树中节点数目范围在[1, 10⁴] 内
- -2³¹ ≤ Node.val ≤ 2³¹ - 1

#### 解题思路

**核心思想：** 使用递归方法验证BST，为每个节点维护一个有效值范围。根据BST的性质，左子树的所有节点值必须小于当前节点，右子树的所有节点值必须大于当前节点。

**算法步骤：**

1. 定义递归函数，传入节点和有效值范围（最小值、最大值）
2. 如果节点为空，返回true（空树是有效的BST）
3. 检查当前节点值是否在有效范围内
4. 递归验证左子树（更新最大值为当前节点值）
5. 递归验证右子树（更新最小值为当前节点值）
6. 返回所有条件的逻辑与结果

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class IsValidBST {
   public boolean isValidBST(TreeNode root) {
      return validateBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
   }

   private boolean validateBST(TreeNode node, long minValue, long maxValue) {
      if (node == null) return true;

      if (node.val <= minValue || node.val >= maxValue) return false;

      return validateBST(node.left, minValue, node.val) &&
              validateBST(node.right, node.val, maxValue);
   }
}
```

**Kotlin版本：**

```kotlin
fun isValidBST(root: TreeNode?): Boolean {
   fun validateBST(node: TreeNode?, minValue: Long, maxValue: Long): Boolean {
      if (node == null) return true

      if (node.`val` <= minValue || node.`val` >= maxValue) return false

      return validateBST(node.left, minValue, node.`val`.toLong()) &&
              validateBST(node.right, node.`val`.toLong(), maxValue)
   }

   return validateBST(root, Long.MIN_VALUE, Long.MAX_VALUE)
}
```

**范围验证解法的优势：**

- 一次遍历即可完成验证，效率高
- 利用BST的性质，逻辑清晰直观
- 正确处理了边界情况和重复值问题

### [二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

**题目描述：**
给定一个二叉搜索树的根节点 `root`，和一个整数 `k`，请你设计一个算法查找其中第 `k` 个最小元素（从1开始计数）。

**示例：**

```
输入：root = [3,1,4,null,2], k = 1
输出：1

输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3

输入：root = [1], k = 1
输出：1
```

**约束条件：**

- 树中的节点数为 n
- 1 ≤ k ≤ n ≤ 10⁴
- 0 ≤ Node.val ≤ 10⁴

#### 解题思路

**核心思想：** 利用二叉搜索树的中序遍历结果是有序序列的特性。通过中序遍历找到第k个访问的节点即为第k小的元素。

**算法步骤：**

1. 使用栈进行迭代中序遍历
2. 初始化计数器和当前节点指针
3. 重复以下步骤直到找到结果：
   - 将当前节点及其所有左子节点入栈
   - 弹出栈顶节点，计数器加1
   - 如果计数器等于k，返回当前节点值
   - 移动到右子树继续遍历
4. 返回第k小的元素值

**时间复杂度：** O(H + k) - H是树的高度，最多访问k个节点
**空间复杂度：** O(H) - 栈的最大深度等于树的高度

#### 代码实现

**Java版本：**

```java
public class KthSmallest {
   public int kthSmallest(TreeNode root, int k) {
      ArrayDeque<TreeNode> stack = new ArrayDeque<>();
      TreeNode current = root;
      int count = 0;

      while (current != null || !stack.isEmpty()) {
         while (current != null) {
            stack.addLast(current);
            current = current.left;
         }

         current = stack.removeLast();
         count++;

         if (count == k) {
            return current.val;
         }

         current = current.right;
      }

      return -1;
   }
}
```

**Kotlin版本：**

```kotlin
fun kthSmallest(root: TreeNode?, k: Int): Int {
   val stack = ArrayDeque<TreeNode>()
   var current = root
   var count = 0

   while (current != null || stack.isNotEmpty()) {
      while (current != null) {
         stack.addLast(current)
         current = current.left
      }

      current = stack.removeLast()
      count++

      if (count == k) {
         return current.`val`
      }

      current = current.right
   }

   return -1
}
```

**中序遍历解法的优势：**

- 充分利用BST的有序性质，无需额外排序
- 提前终止遍历，效率高于完整遍历
- 迭代实现避免了递归栈溢出的风险

### [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

**题目描述：**
给定一个二叉树的根节点 `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例：**

```
输入：root = [1,2,3,null,5,null,4]
输出：[1,3,4]

输入：root = [1,null,3]
输出：[1,3]

输入：root = []
输出：[]
```

**约束条件：**

- 二叉树的节点个数的范围是 [0, 100]
- -100 ≤ Node.val ≤ 100

#### 解题思路

**核心思想：** 使用层序遍历（BFS）的方法，对于每一层，只记录最右侧的节点值。通过先处理右子节点再处理左子节点的方式，确保每层的第一个访问节点就是最右侧节点。

**算法步骤：**

1. 如果根节点为空，返回空列表
2. 初始化队列并将根节点入队
3. 对每一层进行遍历：
   - 记录当前层的节点数量
   - 将第一个处理的节点值加入结果（最右侧节点）
   - 按照右子节点优先的顺序将子节点入队
4. 返回每层最右侧节点值的列表

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(w) - w是树的最大宽度

#### 代码实现

**Java版本：**

```Java
public class RightSideView {

   public List<Integer> rightSideView(TreeNode root) {
      if (root == null) return Collections.emptyList();
      ArrayDeque<TreeNode> deque = new ArrayDeque<>();
      deque.add(root);
      int layer = 0;
      List<Integer> result = new ArrayList<>();

      while (!deque.isEmpty()) {
         int size = deque.size();
         layer++;
         while (size-- != 0) {
            TreeNode polled = deque.pollFirst();
            if (layer > result.size()) {
               result.add(polled.val);
            }
            if (polled.right != null) deque.add(polled.right);
            if (polled.left != null) deque.add(polled.left);
         }
      }
      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun rightSideView(root: TreeNode?): List<Int> {
   // 处理空树情况  
   root ?: return emptyList()

   // 使用双端队列存储当前层的节点，初始时添加根节点  
   val queue = ArrayDeque<TreeNode>().apply { addFirst(root) }
   val result = mutableListOf<Int>()

   // 逐层遍历二叉树  
   while (queue.isNotEmpty()) {
      // 记录当前层最右侧节点的值（从右侧看到的节点）  
      result.add(queue.first().`val`)

      // 遍历当前层的所有节点  
      repeat(queue.size) {
         // 当前节点出队  
         val node = queue.removeLast()

         // 按照从左到右的顺序将子节点入队  
         // 注意我们使用addFirst，这样队首就是最右侧的节点  
         node.left?.let { queue.addFirst(it) }
         node.right?.let { queue.addFirst(it) }
      }
   }

   return result
}
```

**层序遍历解法的优势：**

- 通过层序遍历自然地按层处理，每层只取最右侧节点
- 使用队列数据结构，逻辑清晰易懂
- 时间复杂度O(n)，空间复杂度取决于树的最大宽度
- 可以轻松扩展为获取左视图或其他层次相关问题

### [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

**题目描述：**
给定一个二叉树的根节点 `root`，将该二叉树展开为一个单链表。展开后的单链表应该同样使用 TreeNode，其中 right
子指针指向链表中下一个结点，而左子指针始终为 null。展开后的单链表应该与二叉树 **先序遍历** 顺序相同。

**示例：**

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]

输入：root = []
输出：[]

输入：root = [0]
输出：[0]
```

**约束条件：**

- 树中结点数在范围 [0, 2000] 内
- -100 ≤ Node.val ≤ 100

#### 解题思路

**核心思想：** 使用递归方法将二叉树展开为链表。先递归处理左右子树，然后将左子树移到右子树位置，再将原右子树接到新右子树的末尾，确保展开顺序符合先序遍历。

**算法步骤：**

1. 如果当前节点为空，直接返回
2. 递归展开左子树和右子树
3. 保存原右子树的引用
4. 将左子树移到右子树位置，并将左指针置为null
5. 找到新右子树的最右节点
6. 将原右子树接到新右子树的末尾

**时间复杂度：** O(n) - 每个节点访问常数次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class Flatten {
   public void flatten(TreeNode root) {
      if (root == null) return;

      TreeNode leftSubtree = root.left;
      TreeNode rightSubtree = root.right;

      // 先将左右子树分别展平
      flatten(leftSubtree);
      flatten(rightSubtree);

      // 将左子树接到根节点的右侧
      root.left = null; // 将左指针设为null

      if (leftSubtree != null) {
         // 将左子树接到右侧
         root.right = leftSubtree;

         // 找到左子树展平后的最右节点
         TreeNode current = leftSubtree;
         while (current.right != null) {
            current = current.right;
         }

         // 将原来的右子树接到当前右侧末尾
         current.right = rightSubtree;
      } else {
         // 如果没有左子树，保持原来的右子树
         root.right = rightSubtree;
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun flatten(root: TreeNode?): Unit {
   if (root == null) return

   // 递归展平左子树和右子树
   flatten(root.left)
   flatten(root.right)

   // 保存原右子树
   val originalRight = root.right

   // 将左子树移到右子树位置
   root.right = root.left
   root.left = null

   // 找到新右子树的最右节点
   var current = root
   while (current?.right != null) {
      current = current.right
   }

   // 将原右子树接到新右子树的末尾
   current?.right = originalRight
}
```

**递归展开解法的优势：**

- 符合先序遍历的顺序要求，逻辑直观
- 递归处理简化了复杂的指针操作
- 原地修改，空间效率高

### [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked)

**题目描述：**
给定两个整数数组 `preorder` 和 `inorder`，其中 `preorder` 是二叉树的 **先序遍历**，`inorder` 是同一棵树的 **中序遍历**
，请构造并返回这颗二叉树。

**示例：**

```
输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出：[3,9,20,null,null,15,7]

输入：preorder = [-1], inorder = [-1]
输出：[-1]

输入：preorder = [], inorder = []
输出：[]
```

**约束条件：**

- 1 ≤ preorder.length ≤ 3000
- inorder.length == preorder.length
- -3000 ≤ preorder[i], inorder[i] ≤ 3000
- preorder 和 inorder 均无重复元素
- inorder 均出现在 preorder中
- preorder 保证为二叉树的前序遍历序列
- inorder 保证为二叉树的中序遍历序列

#### 解题思路

**核心思想：** 利用前序遍历和中序遍历的特点递归构建二叉树。前序遍历的第一个元素是根节点，在中序遍历中找到根节点位置可以分割左右子树，然后递归构建左右子树。

**算法步骤：**

1. 如果遍历数组为空，返回null
2. 前序遍历的第一个元素是根节点
3. 在中序遍历中找到根节点的位置
4. 根据根节点位置计算左子树的大小
5. 递归构建左子树（使用对应的前序和中序子数组）
6. 递归构建右子树（使用对应的前序和中序子数组）
7. 返回构建的根节点

**时间复杂度：** O(n) - 每个节点处理一次，使用HashMap优化查找
**空间复杂度：** O(n) - 递归调用栈和HashMap的空间

#### 代码实现

**Java版本：**

```java
public class BuildTree {
   public TreeNode buildTree(int[] preorder, int[] inorder) {
      return buildTreeHelper(preorder, inorder, 0, preorder.length - 1, 0, inorder.length - 1);
   }

   private TreeNode buildTreeHelper(int[] preorder, int[] inorder,
                                    int preorderStart, int preorderEnd,
                                    int inorderStart, int inorderEnd) {
      if (preorderStart > preorderEnd) return null;

      int rootValue = preorder[preorderStart];
      TreeNode root = new TreeNode(rootValue);
      int inorderRootIndex = findInorderIndex(inorder, rootValue);
      int leftSubtreeSize = inorderRootIndex - inorderStart;

      TreeNode leftSubtree = buildTreeHelper(preorder, inorder,
              preorderStart + 1, preorderStart + leftSubtreeSize,
              inorderStart, inorderRootIndex - 1);
      TreeNode rightSubtree = buildTreeHelper(preorder, inorder,
              preorderStart + leftSubtreeSize + 1, preorderEnd,
              inorderRootIndex + 1, inorderEnd);

      root.left = leftSubtree;
      root.right = rightSubtree;
      return root;
   }

   private int findInorderIndex(int[] inorder, int target) {
      for (int i = 0; i < inorder.length; i++) {
         if (inorder[i] == target) {
            return i;
         }
      }
      throw new IllegalArgumentException("Target not found in array");
   }
}
```

**Kotlin版本：**

```kotlin
fun buildTree(preorder: IntArray, inorder: IntArray): TreeNode? {
   if (preorder.isEmpty()) return null

   // 创建中序遍历值到索引的映射，避免重复查找
   val inorderMap = inorder.withIndex().associate { it.value to it.index }

   fun buildTreeHelper(preStart: Int, preEnd: Int, inStart: Int, inEnd: Int): TreeNode? {
      if (preStart > preEnd) return null

      // 前序遍历的第一个元素是根节点
      val rootValue = preorder[preStart]
      val root = TreeNode(rootValue)

      // 在中序遍历中找到根节点的位置
      val inorderRootIndex = inorderMap[rootValue]!!

      // 计算左子树的大小
      val leftSubtreeSize = inorderRootIndex - inStart

      // 递归构建左子树和右子树
      root.left = buildTreeHelper(
         preStart + 1,                // 左子树前序遍历的起始位置
         preStart + leftSubtreeSize,  // 左子树前序遍历的结束位置
         inStart,                     // 左子树中序遍历的起始位置
         inorderRootIndex - 1         // 左子树中序遍历的结束位置
      )

      root.right = buildTreeHelper(
         preStart + leftSubtreeSize + 1,  // 右子树前序遍历的起始位置
         preEnd,                          // 右子树前序遍历的结束位置
         inorderRootIndex + 1,            // 右子树中序遍历的起始位置
         inEnd                            // 右子树中序遍历的结束位置
      )

      return root
   }

   return buildTreeHelper(0, preorder.lastIndex, 0, inorder.lastIndex)
}
```

**分治递归解法的优势：**

- 充分利用前序和中序遍历的特性，算法思路自然
- 通过HashMap优化查找，提高时间效率
- 递归分治策略，代码结构清晰易懂

### [路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

**题目描述：**
给定一个二叉树的根节点 `root`，和一个整数 `targetSum`，求该二叉树里节点值之和等于 `targetSum` 的 **路径**
的数目。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例：**

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条：
1. 5 → 3
2. 5 → 2 → 1
3. -3 → 11

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3

输入：root = [], targetSum = 0
输出：0
```

**约束条件：**

- 二叉树的节点个数的范围是 [0, 1000]
- -10⁹ ≤ Node.val ≤ 10⁹
- -1000 ≤ targetSum ≤ 1000

#### 解题思路

**核心思想：** 使用前缀和 + 哈希表的方法优化路径和计算。通过记录从根节点到当前节点的路径前缀和，利用 `当前前缀和 - targetSum`
在哈希表中查找是否存在对应的前缀和，从而快速找到满足条件的路径。

**算法步骤：**

1. 初始化前缀和哈希表，设置前缀和为0的出现次数为1
2. 使用DFS遍历二叉树：
   - 计算当前路径的前缀和
   - 查找 `当前前缀和 - targetSum` 在哈希表中的出现次数
   - 将当前前缀和加入哈希表
   - 递归处理左右子树
   - 回溯时移除当前前缀和（恢复状态）
3. 返回满足条件的路径总数

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(n) - 哈希表和递归调用栈的空间

#### 代码实现

**Java版本：**

```java
public class PathSum {
   public int pathSum(TreeNode root, int targetSum) {
      Map<Long, Integer> prefixSumCount = new HashMap<>();
      prefixSumCount.put(0L, 1);
      return dfs(root, 0L, targetSum, prefixSumCount);
   }

   private int dfs(TreeNode node, long currentSum, int targetSum, Map<Long, Integer> prefixSumCount) {
      if (node == null) return 0;

      currentSum += node.val;

      // 查找符合要求的路径数量
      int pathCount = prefixSumCount.getOrDefault(currentSum - targetSum, 0);

      // 更新当前前缀和的出现次数
      prefixSumCount.merge(currentSum, 1, Integer::sum);

      // 递归处理左右子树
      int totalPaths = pathCount + dfs(node.left, currentSum, targetSum, prefixSumCount)
              + dfs(node.right, currentSum, targetSum, prefixSumCount);

      // 回溯，恢复状态
      prefixSumCount.merge(currentSum, -1, Integer::sum);

      return totalPaths;
   }
}
```

**Kotlin版本：**

```kotlin
fun pathSum(root: TreeNode?, targetSum: Int): Int {
   // 用于存储前缀和及其出现次数
   val prefixSumCount = HashMap<Long, Int>()
   // 初始化前缀和为0的情况，出现1次
   prefixSumCount[0L] = 1

   fun dfs(node: TreeNode?, currentSum: Long, target: Long): Int {
      if (node == null) return 0

      // 当前路径上的前缀和
      val newSum = currentSum + node.`val`
      // 需要查找的前缀和，如果存在则说明有路径和为targetSum
      val complement = newSum - target

      // 获取符合要求的路径数量
      val pathCount = prefixSumCount.getOrDefault(complement, 0)

      // 更新当前前缀和的出现次数
      prefixSumCount[newSum] = prefixSumCount.getOrDefault(newSum, 0) + 1

      // 递归处理左右子树
      val totalPaths = pathCount + dfs(node.left, newSum, target) + dfs(node.right, newSum, target)

      // 回溯，恢复状态，移除当前节点的前缀和记录
      prefixSumCount[newSum] = prefixSumCount.getOrDefault(newSum, 0) - 1

      return totalPaths
   }

   return dfs(root, 0, targetSum.toLong())
}
```

**前缀和哈希表解法的优势：**

- 时间复杂度优化，避免了重复计算路径和
- 利用前缀和技巧，将路径和问题转化为差值查找
- 回溯机制保证了状态的正确性，避免了路径间的干扰

### [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

**题目描述：**
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为："对于有根树 T 的两个节点
p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。"

**示例：**

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。

输入：root = [1,2], p = 1, q = 2
输出：1
```

**约束条件：**

- 树中节点数目在范围 [2, 10⁵] 内
- -10⁹ ≤ Node.val ≤ 10⁹
- 所有 Node.val 互不相同
- p ≠ q
- p 和 q 均存在于给定的二叉树中

#### 解题思路

**核心思想：** 使用递归方法寻找最近公共祖先。如果当前节点是 p 或 q 中的一个，直接返回当前节点。否则递归查找左右子树，如果左右子树都找到了目标节点，说明当前节点就是最近公共祖先。

**算法步骤：**

1. 如果当前节点为空，返回null
2. 如果当前节点是 p 或 q，返回当前节点
3. 递归查找左子树和右子树
4. 如果左右子树都找到了节点，当前节点是最近公共祖先
5. 如果只有一边找到了节点，返回找到的那一边
6. 如果都没找到，返回null

**时间复杂度：** O(n) - 最坏情况下访问所有节点
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class LowestCommonAncestor {
   public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
      if (root == null) return null;
      if (root == p || root == q) return root;

      TreeNode leftResult = lowestCommonAncestor(root.left, p, q);
      TreeNode rightResult = lowestCommonAncestor(root.right, p, q);

      if (leftResult != null && rightResult != null) return root;
      if (leftResult != null) return leftResult;
      if (rightResult != null) return rightResult;
      return null;
   }
}
```

**Kotlin版本：**

```kotlin
fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? = when {
   root == null || root == p || root == q -> root
   else -> {
      val leftResult = lowestCommonAncestor(root.left, p, q)
      val rightResult = lowestCommonAncestor(root.right, p, q)
      when {
         leftResult != null && rightResult != null -> root
         else -> leftResult ?: rightResult
      }
   }
}
```

**递归查找解法的优势：**

- 算法逻辑清晰，直接按照最近公共祖先的定义实现
- 一次遍历即可完成查找，效率高
- 代码简洁，易于理解和实现

### [二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

**题目描述：**
二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次**
。该路径 **至少包含一个** 节点，且不一定经过根节点。**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其
**最大路径和** 。

**示例：**

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6

输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42

输入：root = [-3]
输出：-3
```

**约束条件：**

- 树中节点数目范围是 [1, 3 * 10⁴]
- -1000 ≤ Node.val ≤ 1000

#### 解题思路

**核心思想：** 使用递归方法计算每个节点的最大路径和。对于每个节点，计算通过该节点的最大路径和，同时维护全局最大值。需要区分两个概念：通过当前节点的最大路径和（用于更新全局最大值）和从当前节点出发的最大路径和（用于递归返回）。

**算法步骤：**

1. 初始化全局最大路径和
2. 对每个节点递归计算：
   - 如果节点为空，返回0
   - 计算左子树的最大增益（负数时取0）
   - 计算右子树的最大增益（负数时取0）
   - 更新全局最大路径和（当前节点值 + 左增益 + 右增益）
   - 返回当前节点能提供的最大增益（当前节点值 + max(左增益, 右增益)）
3. 返回全局最大路径和

**时间复杂度：** O(n) - 每个节点访问一次
**空间复杂度：** O(h) - h是树的高度，递归调用栈的深度

#### 代码实现

**Java版本：**

```java
public class MaxPathSum {
   private int maxPathSum = Integer.MIN_VALUE;

   public int maxPathSum(TreeNode root) {
      calculateMaxGain(root);
      return maxPathSum;
   }

   private int calculateMaxGain(TreeNode node) {
      if (node == null) return 0;

      int leftGain = Math.max(calculateMaxGain(node.left), 0);
      int rightGain = Math.max(calculateMaxGain(node.right), 0);

      // 更新全局最大路径和
      maxPathSum = Math.max(maxPathSum, node.val + leftGain + rightGain);

      // 返回当前节点能提供的最大增益
      return node.val + Math.max(leftGain, rightGain);
   }
}
```

**Kotlin版本：**

```kotlin
fun maxPathSum(root: TreeNode): Int {
   var result = Int.MIN_VALUE
   fun TreeNode?.calculateMaxGain(): Int = this?.run {
      val leftGain = left.calculateMaxGain().coerceAtLeast(0)
      val rightGain = right.calculateMaxGain().coerceAtLeast(0)

      result = maxOf(result, leftGain + rightGain + `val`)
      `val` + maxOf(leftGain, rightGain)
   } ?: 0
   root.calculateMaxGain()
   return result
}
```

**递归增益计算解法的优势：**

- 巧妙地区分了两种路径概念，算法设计精妙
- 一次遍历即可完成计算，时间效率高
- 通过负数增益归零处理，自然地处理了负值节点的情况

## 图论

### [岛屿数量](https://leetcode.cn/problems/number-of-islands/)

**题目描述：**
给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例：**

```
示例 1：
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

示例 2：
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**约束条件：**

- m == grid.length
- n == grid[i].length
- 1 ≤ m, n ≤ 300
- grid[i][j] 的值为 '0' 或 '1'

#### 解题思路

**核心思想：** 使用深度优先搜索（DFS）遍历二维网格。每当遇到一个未访问的陆地（'1'
），就从该点开始DFS，将连通的所有陆地标记为已访问，这样一次DFS就代表找到了一个岛屿。

**算法步骤：**

1. 遍历整个二维网格
2. 当遇到值为'1'的陆地时，岛屿数量+1
3. 从该陆地开始DFS，将所有连通的陆地标记为'0'（避免重复计算）
4. DFS过程中检查四个方向的相邻位置
5. 继续遍历直到处理完所有位置

**时间复杂度：** O(M × N) - M和N分别是网格的行数和列数
**空间复杂度：** O(M × N) - 最坏情况下递归深度为网格大小

#### 代码实现

**Java版本：**

```Java
public class NumIslands {

   private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};

   public int numIslands(char[][] grid) {
      if (grid == null || grid.length == 0 || grid[0].length == 0) {
         return 0;
      }

      int islandCount = 0;
      int rows = grid.length;
      int cols = grid[0].length;

      for (int row = 0; row < rows; row++) {
         for (int col = 0; col < cols; col++) {
            if (grid[row][col] == '1') {
               markIslandAsVisited(grid, row, col);
               islandCount++;
            }
         }
      }

      return islandCount;
   }

   private void markIslandAsVisited(char[][] grid, int row, int col) {
      if (!isValidPosition(grid, row, col) || grid[row][col] == '0') {
         return;
      }

      grid[row][col] = '0';

      for (int[] direction : DIRECTIONS) {
         int newRow = row + direction[0];
         int newCol = col + direction[1];
         markIslandAsVisited(grid, newRow, newCol);
      }
   }

   private boolean isValidPosition(char[][] grid, int row, int col) {
      return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;
   }
}
```

**Kotlin版本：**

```kotlin
fun numIslands(grid: Array<CharArray>): Int {
   if (grid.isEmpty() || grid[0].isEmpty()) return 0

   val rows = grid.size
   val cols = grid[0].size
   val directions = arrayOf(Pair(-1, 0), Pair(1, 0), Pair(0, -1), Pair(0, 1))
   var islandCount = 0

   fun isValidPosition(row: Int, col: Int) = row in 0 until rows && col in 0 until cols

   fun markIslandAsVisited(row: Int, col: Int) {
      if (!isValidPosition(row, col) || grid[row][col] != '1') return

      grid[row][col] = '0'

      directions.forEach { (deltaRow, deltaCol) ->
         markIslandAsVisited(row + deltaRow, col + deltaCol)
      }
   }

   for (row in 0 until rows) {
      for (col in 0 until cols) {
         if (grid[row][col] == '1') {
            islandCount++
            markIslandAsVisited(row, col)
         }
      }
   }

   return islandCount
}
```

**DFS解法的优势：**

- 时间复杂度O(M × N)，每个格子最多访问一次
- 自然地处理连通性问题，一次DFS即可标记整个岛屿
- 空间使用原地修改，不需要额外的visited数组
- 实现简洁，递归逻辑清晰易懂

### [腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

**题目描述：**
在给定的 m x n 网格中，每个单元格可以有以下三个值之一：

- 值 0 代表空单元格；
- 值 1 代表新鲜橘子；
- 值 2 代表腐烂的橘子。

每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。

**示例：**

```
示例 1：
输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4

示例 2：
输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正方向上。

示例 3：
输入：grid = [[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```

**约束条件：**

- m == grid.length
- n == grid[i].length
- 1 ≤ m, n ≤ 10
- grid[i][j] 仅为 0、1 或 2

#### 解题思路

**核心思想：** 使用广度优先搜索（BFS）模拟橘子腐烂的过程。每一轮BFS代表一分钟，同时处理所有当前腐烂的橘子，将它们相邻的新鲜橘子变为腐烂状态。

**算法步骤：**

1. 遍历网格，统计新鲜橘子数量，将所有腐烂橘子的位置加入队列
2. 如果没有新鲜橘子，直接返回0
3. 进行BFS：每一轮处理队列中的所有腐烂橘子
4. 对每个腐烂橘子，检查四个方向的相邻位置
5. 将相邻的新鲜橘子变为腐烂，加入队列，新鲜橘子数量减1
6. 每完成一轮BFS，分钟数加1
7. 当队列为空或没有新鲜橘子时结束
8. 如果还有新鲜橘子，返回-1；否则返回分钟数

**时间复杂度：** O(M × N) - 每个单元格最多被访问一次
**空间复杂度：** O(M × N) - 队列最多存储所有单元格

#### 代码实现

**Java版本：**

```Java
public class OrangesRotting {

   private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
   private static final int EMPTY = 0;
   private static final int FRESH = 1;
   private static final int ROTTEN = 2;

   public int orangesRotting(int[][] grid) {
      if (grid == null || grid.length == 0 || grid[0].length == 0) {
         return 0;
      }

      int rows = grid.length;
      int cols = grid[0].length;
      int freshCount = 0;
      Queue<int[]> rottenQueue = new ArrayDeque<>();
      int minutes = 0;

      // 统计新鲜橘子数量并将腐烂橘子加入队列
      for (int row = 0; row < rows; row++) {
         for (int col = 0; col < cols; col++) {
            if (grid[row][col] == FRESH) {
               freshCount++;
            } else if (grid[row][col] == ROTTEN) {
               rottenQueue.offer(new int[]{row, col});
            }
         }
      }

      // 如果没有新鲜橘子，直接返回0
      if (freshCount == 0) {
         return 0;
      }

      // BFS模拟腐烂过程
      while (!rottenQueue.isEmpty() && freshCount > 0) {
         int queueSize = rottenQueue.size();

         // 处理当前分钟所有腐烂的橘子
         for (int i = 0; i < queueSize; i++) {
            int[] current = rottenQueue.poll();
            int currentRow = current[0];
            int currentCol = current[1];

            // 检查四个方向
            for (int[] direction : DIRECTIONS) {
               int newRow = currentRow + direction[0];
               int newCol = currentCol + direction[1];

               if (isValidPosition(rows, cols, newRow, newCol) &&
                       grid[newRow][newCol] == FRESH) {
                  grid[newRow][newCol] = ROTTEN;
                  freshCount--;
                  rottenQueue.offer(new int[]{newRow, newCol});
               }
            }
         }
         minutes++;
      }

      return freshCount == 0 ? minutes : -1;
   }

   private boolean isValidPosition(int rows, int cols, int row, int col) {
      return row >= 0 && row < rows && col >= 0 && col < cols;
   }
}
```

**Kotlin版本：**

```kotlin
private const val EMPTY = 0
private const val FRESH = 1
private const val ROTTEN = 2

fun orangesRotting(grid: Array<IntArray>): Int {
   if (grid.isEmpty() || grid[0].isEmpty()) return 0

   val rows = grid.size
   val cols = grid[0].size
   val directions = arrayOf(Pair(-1, 0), Pair(1, 0), Pair(0, -1), Pair(0, 1))
   val rottenQueue = ArrayDeque<Pair<Int, Int>>()
   var freshCount = 0
   var minutes = 0

   fun isValidPosition(row: Int, col: Int) = row in 0 until rows && col in 0 until cols

   // 统计新鲜橘子数量并将腐烂橘子加入队列
   for (row in 0 until rows) {
      for (col in 0 until cols) {
         when (grid[row][col]) {
            FRESH -> freshCount++
            ROTTEN -> rottenQueue.add(Pair(row, col))
         }
      }
   }

   // 如果没有新鲜橘子，直接返回0
   if (freshCount == 0) return 0

   // BFS模拟腐烂过程
   while (rottenQueue.isNotEmpty() && freshCount > 0) {
      // 处理当前分钟所有腐烂的橘子
      repeat(rottenQueue.size) {
         val (currentRow, currentCol) = rottenQueue.removeFirst()

         // 检查四个方向的相邻位置
         for ((deltaRow, deltaCol) in directions) {
            val newRow = currentRow + deltaRow
            val newCol = currentCol + deltaCol

            // 检查新坐标是否在网格内且是新鲜橘子
            if (isValidPosition(newRow, newCol) && grid[newRow][newCol] == FRESH) {
               // 将新鲜橘子标记为腐烂
               grid[newRow][newCol] = ROTTEN
               freshCount--
               rottenQueue.add(Pair(newRow, newCol))
            }
         }
      }
      minutes++
   }

   return if (freshCount == 0) minutes else -1
}
```

**BFS解法的优势：**

- 时间复杂度O(M × N)，每个单元格最多被访问一次
- 自然地模拟时间流逝过程，每轮BFS代表一分钟
- 使用队列确保同一时刻腐烂的橘子同时处理
- 能准确计算最小时间，适合求解最短路径类问题

### [课程表](https://leetcode.cn/problems/course-schedule/?envType=study-plan-v2&envId=top-100-liked)

**题目描述：**
你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程
ai 则 必须 先学习课程 bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。

请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

**示例：**

```
示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

示例 2：
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

**约束条件：**

- 1 ≤ numCourses ≤ 2000
- 0 ≤ prerequisites.length ≤ 5000
- prerequisites[i].length == 2
- 0 ≤ ai, bi < numCourses
- prerequisites[i] 中的所有课程对 互不相同

#### 解题思路

**核心思想：** 这是一个检测有向图中是否存在环的问题。使用深度优先搜索（DFS）来检测图中的环。如果存在环，则无法完成所有课程；否则可以完成。

**算法步骤：**

1. 根据先修课程关系构建邻接表表示的有向图
2. 使用三种状态标记节点：0=未访问，1=访问中，2=已完成访问
3. 对每个未访问的节点进行DFS
4. 在DFS过程中，如果遇到状态为"访问中"的节点，说明存在环
5. 如果DFS过程中没有发现环，则可以完成所有课程

**时间复杂度：** O(V + E) - V是课程数量，E是先修关系数量
**空间复杂度：** O(V + E) - 邻接表和递归栈的空间

#### 代码实现

**Java版本：**

```Java
public class CanFinish {

   private static final int UNVISITED = 0;
   private static final int VISITING = 1;
   private static final int VISITED = 2;

   public boolean canFinish(int numCourses, int[][] prerequisites) {
      // 构建邻接表表示的有向图
      Set<Integer>[] graph = buildGraph(numCourses, prerequisites);

      // 节点状态数组：0=未访问，1=访问中，2=已访问
      int[] states = new int[numCourses];

      // 对每个未访问的节点进行DFS检查
      for (int course = 0; course < numCourses; course++) {
         if (states[course] == UNVISITED && hasCycle(graph, course, states)) {
            return false;
         }
      }

      return true;
   }

   /**
    * 使用DFS检查从指定课程开始是否存在环
    *
    * @param graph   邻接表表示的图
    * @param course  当前课程
    * @param states  节点状态数组
    * @return 是否存在环
    */
   private boolean hasCycle(Set<Integer>[] graph, int course, int[] states) {
      // 如果当前课程正在访问中，说明形成了环
      if (states[course] == VISITING) {
         return true;
      }

      // 如果当前课程已经访问完成，跳过
      if (states[course] == VISITED) {
         return false;
      }

      // 标记当前课程为访问中
      states[course] = VISITING;

      // 递归检查所有依赖的课程
      for (int prerequisite : graph[course]) {
         if (hasCycle(graph, prerequisite, states)) {
            return true;
         }
      }

      // 标记当前课程为已访问
      states[course] = VISITED;
      return false;
   }

   /**
    * 根据先修课程关系构建邻接表
    *
    * @param numCourses    课程总数
    * @param prerequisites 先修课程关系
    * @return 邻接表表示的图
    */
   private Set<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
      Set<Integer>[] graph = new HashSet[numCourses];

      for (int i = 0; i < numCourses; i++) {
         graph[i] = new HashSet<>();
      }

      for (int[] prerequisite : prerequisites) {
         int course = prerequisite[0];
         int prereq = prerequisite[1];
         // course依赖于prereq，在图中从course指向prereq
         graph[course].add(prereq);
      }

      return graph;
   }
}
```

**Kotlin版本：**

```kotlin
private const val UNVISITED = 0
private const val VISITING = 1
private const val VISITED = 2
fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
   // 构建邻接表表示的有向图  
   val graph = buildGraph(numCourses, prerequisites)

   // 节点状态数组：0=未访问，1=访问中，2=已访问  
   val states = IntArray(numCourses)

   /**
    * 使用DFS检查从指定课程开始是否存在环
    */
   fun hasCycle(course: Int): Boolean {
      // 如果当前课程正在访问中，说明形成了环  
      if (states[course] == VISITING) {
         return true
      }

      // 如果当前课程已经访问完成，跳过  
      if (states[course] == VISITED) {
         return false
      }

      // 标记当前课程为访问中  
      states[course] = VISITING

      // 递归检查所有依赖的课程  
      for (prerequisite in graph.getValue(course)) {
         if (hasCycle(prerequisite)) {
            return true
         }
      }
      // 标记当前课程为已访问  
      states[course] = VISITED
      return false
   }

   // 对每个未访问的节点进行DFS检查  
   return (0 until numCourses).all { course ->
      states[course] != UNVISITED || !hasCycle(course)
   }
}

/**
 * 根据先修课程关系构建邻接表
 */
private fun buildGraph(numCourses: Int, prerequisites: Array<IntArray>): Map<Int, List<Int>> {
   return prerequisites.groupBy({ it[0] }, { it[1] }).withDefault { emptyList() }
}
```

**环检测解法的优势：**

- 时间复杂度O(V + E)，每个节点和边最多访问一次
- 使用三色标记法精确检测有向图中的环
- 空间复杂度优化，使用整数数组而非HashSet
- 适用于所有拓扑排序和环检测问题

### [实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)

**题目描述：**
Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

- Trie() 初始化前缀树对象。
- void insert(String word) 向前缀树中插入字符串 word 。
- boolean search(String word) 返回字符串 word 是否在前缀树中存在（即，在检索之前已经插入）。
- boolean startsWith(String prefix) 返回之前是否存在字符串以 prefix 为前缀。

**示例：**

```
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]

输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

**约束条件：**

- 1 ≤ word.length, prefix.length ≤ 2000
- word 和 prefix 仅由小写英文字母组成
- insert、search 和 startsWith 调用次数 总计 不超过 3 * 10^4 次

#### 解题思路

**核心思想：** Trie是一种多叉树结构，每个节点包含子节点数组和标记位。从根节点到某个节点的路径对应一个字符串的前缀，标记位表示是否为完整单词的结尾。

**算法步骤：**

1. 设计节点结构：包含26个子节点（对应a-z）和布尔标记位
2. 插入操作：从根节点开始，沿着字符路径创建或遍历节点，最后标记结尾
3. 搜索操作：从根节点开始沿字符路径遍历，检查是否存在且为单词结尾
4. 前缀检查：类似搜索，但只需检查路径是否存在，不需要结尾标记

**时间复杂度：**

- 插入：O(M) - M是字符串长度
- 搜索：O(M) - M是字符串长度
- 前缀检查：O(M) - M是前缀长度

**空间复杂度：** O(ALPHABET_SIZE * N * M) - N是字符串数量，M是平均长度

#### 代码实现

**Java版本：**

```Java
class Trie {

   private static final int ALPHABET_SIZE = 26;
   private final TrieNode root;

   /**
    * Trie节点定义
    */
   private static class TrieNode {
      TrieNode[] children;
      boolean isEndOfWord;

      public TrieNode() {
         this.children = new TrieNode[ALPHABET_SIZE];
         this.isEndOfWord = false;
      }
   }

   /**
    * 初始化Trie对象
    */
   public Trie() {
      root = new TrieNode();
   }

   /**
    * 向Trie中插入单词
    *
    * @param word 要插入的单词
    */
   public void insert(String word) {
      TrieNode current = root;

      for (char ch : word.toCharArray()) {
         int index = ch - 'a';
         if (current.children[index] == null) {
            current.children[index] = new TrieNode();
         }
         current = current.children[index];
      }

      current.isEndOfWord = true;
   }

   /**
    * 搜索Trie中是否存在完整的单词
    *
    * @param word 要搜索的单词
    * @return 单词是否存在
    */
   public boolean search(String word) {
      TrieNode node = searchPrefix(word);
      return node != null && node.isEndOfWord;
   }

   /**
    * 检查是否存在以给定前缀开头的单词
    *
    * @param prefix 要检查的前缀
    * @return 是否存在该前缀
    */
   public boolean startsWith(String prefix) {
      return searchPrefix(prefix) != null;
   }

   /**
    * 搜索前缀对应的节点
    *
    * @param prefix 前缀字符串
    * @return 对应的节点，如果不存在返回null
    */
   private TrieNode searchPrefix(String prefix) {
      TrieNode current = root;

      for (char ch : prefix.toCharArray()) {
         int index = ch - 'a';
         if (current.children[index] == null) {
            return null;
         }
         current = current.children[index];
      }

      return current;
   }
}
```

**Kotlin版本：**

```kotlin
class Trie {
   private val root = TrieNode()

   companion object {
      private const val ALPHABET_SIZE = 26
   }

   /**
    * Trie节点定义
    */
   private data class TrieNode(
      val children: Array<TrieNode?> = arrayOfNulls(ALPHABET_SIZE),
      var isEndOfWord: Boolean = false
   ) {
      override fun equals(other: Any?): Boolean {
         if (this === other) return true
         if (javaClass != other?.javaClass) return false
         other as TrieNode
         if (!children.contentEquals(other.children)) return false
         if (isEndOfWord != other.isEndOfWord) return false
         return true
      }

      override fun hashCode(): Int {
         var result = children.contentHashCode()
         result = 31 * result + isEndOfWord.hashCode()
         return result
      }
   }

   /**
    * 向Trie中插入单词
    *
    * @param word 要插入的单词
    */
   fun insert(word: String) {
      word.fold(root) { current, char ->
         val index = char - 'a'
         if (current.children[index] == null) {
            current.children[index] = TrieNode()
         }
         current.children[index]!!
      }.isEndOfWord = true
   }

   /**
    * 搜索Trie中是否存在完整的单词
    *
    * @param word 要搜索的单词
    * @return 单词是否存在
    */
   fun search(word: String): Boolean {
      val node = searchPrefix(word)
      return node?.isEndOfWord == true
   }

   /**
    * 检查是否存在以给定前缀开头的单词
    *
    * @param prefix 要检查的前缀
    * @return 是否存在该前缀
    */
   fun startsWith(prefix: String): Boolean {
      return searchPrefix(prefix) != null
   }

   /**
    * 搜索前缀对应的节点
    *
    * @param prefix 前缀字符串
    * @return 对应的节点，如果不存在返回null
    */
   private fun searchPrefix(prefix: String): TrieNode? {
      return prefix.fold(root) { current, char ->
         val index = char - 'a'
         current.children[index] ?: return null
      }
   }
}
```

**Trie数据结构的优势：**

- 插入和搜索时间复杂度都是O(M)，M为字符串长度
- 支持高效的前缀匹配，适用于自动补全功能
- 相比哈希表，能更好地处理前缀相关的操作
- 空间效率高，公共前缀只存储一次

## 回溯

### [全排列](https://leetcode.cn/problems/permutations/)

**题目描述：**
给定一个不含重复数字的数组 nums，返回其所有可能的全排列。你可以按任意顺序返回答案。

**示例：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

输入：nums = [0,1]
输出：[[0,1],[1,0]]

输入：nums = [1]
输出：[[1]]
```

**约束条件：**

- 1 ≤ nums.length ≤ 6
- -10 ≤ nums[i] ≤ 10
- nums 中的所有整数互不相同

#### 解题思路

**核心思想：** 使用回溯算法枚举所有可能的排列。对于每个位置，尝试所有未使用的数字，递归构建排列，完成后回溯到上一步继续尝试其他可能。

**算法步骤：**

1. 使用布尔数组记录数字使用状态
2. 递归构建当前排列路径
3. 当路径长度等于数组长度时，找到一个完整排列
4. 回溯时撤销选择，尝试其他可能

**时间复杂度：** O(n! × n) - 共有n!种排列，每种排列需要O(n)时间复制
**空间复杂度：** O(n) - 递归深度和辅助数组空间

#### 代码实现

**Java版本：**

```java
public class Permute {
   public List<List<Integer>> permute(int[] nums) {
      List<List<Integer>> result = new ArrayList<>();
      ArrayDeque<Integer> path = new ArrayDeque<>();
      boolean[] used = new boolean[nums.length];
      backtrack(nums, used, path, result);
      return result;
   }

   public void backtrack(int[] nums, boolean[] used, ArrayDeque<Integer> path, List<List<Integer>> result) {
      if (path.size() == nums.length) {
         result.add(new ArrayList<>(path));
         return;
      }

      for (int i = 0; i < nums.length; i++) {
         if (used[i]) continue;

         used[i] = true;
         path.addLast(nums[i]);
         backtrack(nums, used, path, result);
         path.removeLast();
         used[i] = false;
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun permute(nums: IntArray): List<List<Int>> {
   val result = mutableListOf<List<Int>>()
   val path = mutableListOf<Int>()
   val used = BooleanArray(nums.size)

   fun backtrack() {
      if (path.size == nums.size) {
         result.add(path.toList())
         return
      }

      for (i in nums.indices) {
         if (used[i]) continue

         used[i] = true
         path.add(nums[i])
         backtrack()
         path.removeAt(path.lastIndex)
         used[i] = false
      }
   }
   backtrack()
   return result
}
```

**回溯算法的优势：**

- 系统性地枚举所有可能的解
- 通过剪枝可以避免无效的搜索
- 空间效率高，只需要O(n)的额外空间

### [子集](https://leetcode.cn/problems/subsets/)

**题目描述：**
给你一个整数数组 nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。你可以按任意顺序返回解集。

**示例：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

输入：nums = [0]
输出：[[],[0]]
```

**约束条件：**

- 1 ≤ nums.length ≤ 10
- -10 ≤ nums[i] ≤ 10
- nums 中的所有元素互不相同

#### 解题思路

**核心思想：** 使用回溯算法枚举所有可能的子集。对于每个元素，都有选择和不选择两种情况，通过递归的方式构建所有可能的组合。

**算法步骤：**

1. 从索引0开始，对每个位置的元素进行选择
2. 每次递归时，将当前路径加入结果集
3. 尝试添加当前索引及之后的每个元素
4. 递归完成后回溯，移除最后添加的元素

**时间复杂度：** O(2^n × n) - 共有2^n个子集，每个子集复制需要O(n)时间
**空间复杂度：** O(n) - 递归深度和路径存储空间

#### 代码实现

**Java版本：**

```java
public class Subsets {
   public List<List<Integer>> subsets(int[] nums) {
      List<List<Integer>> result = new ArrayList<>();
      ArrayDeque<Integer> path = new ArrayDeque<>();
      backtrack(nums, 0, path, result);
      return result;
   }

   public void backtrack(int[] nums, int startIndex, ArrayDeque<Integer> path, List<List<Integer>> result) {
      result.add(new ArrayList<>(path));

      for (int i = startIndex; i < nums.length; i++) {
         path.addLast(nums[i]);
         backtrack(nums, i + 1, path, result);
         path.removeLast();
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun subsets(nums: IntArray): List<List<Int>> {
   val result = mutableListOf<List<Int>>()
   val path = mutableListOf<Int>()

   fun backtrack(startIndex: Int) {
      result.add(path.toList())

      for (i in startIndex until nums.size) {
         path.add(nums[i])
         backtrack(i + 1)
         path.removeAt(path.lastIndex)
      }
   }
   backtrack(0)
   return result
}
```

**子集生成的优势：**

- 逐步构建，避免重复子集
- 时间复杂度最优，无法进一步优化
- 代码简洁，易于理解和实现

### [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

**题目描述：**
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按任意顺序返回。给出数字到字母的映射如下（与电话按键相同）。注意
1 不对应任何字母。

**示例：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

输入：digits = ""
输出：[]

输入：digits = "2"
输出：["a","b","c"]
```

**约束条件：**

- 0 ≤ digits.length ≤ 4
- digits[i] 是范围 ['2', '9'] 的数字

#### 解题思路

**核心思想：** 使用回溯算法枚举所有可能的字母组合。对于输入字符串中的每个数字，尝试该数字对应的所有字母，递归构建组合。

**算法步骤：**

1. 建立数字到字母的映射关系
2. 从第一个数字开始，尝试其对应的每个字母
3. 递归处理下一个数字，直到处理完所有数字
4. 回溯时移除最后添加的字母，尝试其他选择

**时间复杂度：** O(3^m × 4^n) - m是对应3个字母的数字个数，n是对应4个字母的数字个数
**空间复杂度：** O(m + n) - 递归深度和路径存储空间

#### 代码实现

**Java版本：**

```java
public class LetterCombinations {

   static Map<Character, List<Character>> phoneMap;

   static {
      phoneMap = new HashMap<>();
      phoneMap.put('2', List.of('a', 'b', 'c'));
      phoneMap.put('3', List.of('d', 'e', 'f'));
      phoneMap.put('4', List.of('g', 'h', 'i'));
      phoneMap.put('5', List.of('j', 'k', 'l'));
      phoneMap.put('6', List.of('m', 'n', 'o'));
      phoneMap.put('7', List.of('p', 'q', 'r', 's'));
      phoneMap.put('8', List.of('t', 'u', 'v'));
      phoneMap.put('9', List.of('w', 'x', 'y', 'z'));
   }

   public List<String> letterCombinations(String digits) {
      if (digits.isEmpty()) return Collections.emptyList();
      List<String> result = new ArrayList<>();
      StringBuilder path = new StringBuilder(digits.length());
      backtrack(digits, 0, path, result);
      return result;
   }

   public void backtrack(String digits, int index, StringBuilder path, List<String> result) {
      if (path.length() == digits.length()) {
         result.add(path.toString());
         return;
      }

      for (Character letter : phoneMap.get(digits.charAt(index))) {
         path.append(letter);
         backtrack(digits, index + 1, path, result);
         path.deleteCharAt(path.length() - 1);
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun letterCombinations(digits: String): List<String> {
   if (digits.isEmpty()) return emptyList()

   val phoneMap = arrayOf(
      "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
   )

   val result = mutableListOf<String>()
   val path = StringBuilder()

   fun backtrack(index: Int) {
      if (index == digits.length) {
         result.add(path.toString())
         return
      }

      val letters = phoneMap[digits[index].digitToInt()]
      for (letter in letters) {
         path.append(letter)
         backtrack(index + 1)
         path.deleteAt(path.lastIndex)
      }
   }
   backtrack(0)
   return result
}
```

**字母组合的优势：**

- 系统性地枚举所有可能的组合
- 避免了嵌套循环的复杂性
- 空间使用效率高，只存储当前路径

### [组合总和](https://leetcode.cn/problems/combination-sum/)

**题目描述：**
给你一个无重复元素的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为目标数 target
的所有不同组合。candidates 中的同一个数字可以无限制重复被选取。如果至少一个数字的被选数量不同，则两个组合是不同的。

**示例：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。

输入：candidates = [2,3,5], target = 8
输出：[[2,2,2,2],[2,3,3],[3,5]]

输入：candidates = [2], target = 1
输出：[]
```

**约束条件：**

- 1 ≤ candidates.length ≤ 30
- 2 ≤ candidates[i] ≤ 40
- candidates 的所有元素互不相同
- 1 ≤ target ≤ 40

#### 解题思路

**核心思想：** 使用回溯算法枚举所有可能的组合。对于每个候选数字，可以选择使用它（可重复使用）或跳过它，递归构建满足目标和的组合。

**算法步骤：**

1. 对候选数组排序，便于剪枝优化
2. 从起始索引开始，尝试每个候选数字
3. 如果当前和等于目标值，找到一个有效组合
4. 如果当前和超过目标值，进行剪枝
5. 回溯时移除最后添加的数字

**时间复杂度：** O(target^(target/min)) - 最坏情况下的递归深度
**空间复杂度：** O(target/min) - 递归深度和路径存储空间

#### 代码实现

**Java版本：**

```java
public class CombinationSum {
   public List<List<Integer>> combinationSum(int[] candidates, int target) {
      List<List<Integer>> result = new ArrayList<>();
      Arrays.sort(candidates);
      ArrayDeque<Integer> path = new ArrayDeque<>();
      backtrack(candidates, 0, target, path, result);
      return result;
   }

   public void backtrack(int[] candidates, int startIndex, int remainingTarget,
                         ArrayDeque<Integer> path, List<List<Integer>> result) {
      if (remainingTarget == 0) {
         result.add(new ArrayList<>(path));
         return;
      }
      if (remainingTarget < 0) return;

      for (int i = startIndex; i < candidates.length; i++) {
         if (candidates[i] > remainingTarget) break;

         path.addLast(candidates[i]);
         backtrack(candidates, i, remainingTarget - candidates[i], path, result);
         path.removeLast();
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun combinationSum(candidates: IntArray, target: Int): List<List<Int>> {
   candidates.sort()
   val result = mutableListOf<List<Int>>()
   val path = mutableListOf<Int>()

   fun backtrack(startIndex: Int, remainingTarget: Int) {
      if (remainingTarget == 0) {
         result.add(path.toList())
         return
      }
      if (remainingTarget < 0) return

      for (i in startIndex until candidates.size) {
         if (candidates[i] > remainingTarget) break

         path.add(candidates[i])
         backtrack(i, remainingTarget - candidates[i])
         path.removeAt(path.lastIndex)
      }
   }
   backtrack(0, target)
   return result
}
```

**组合总和的优势：**

- 通过排序和剪枝大幅减少搜索空间
- 允许重复使用元素，扩展了问题的适用性
- 递归结构清晰，易于理解和调试

### [括号生成](https://leetcode.cn/problems/generate-parentheses/)

**题目描述：**
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。

**示例：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

输入：n = 1
输出：["()"]
```

**约束条件：**

- 1 ≤ n ≤ 8

#### 解题思路

**核心思想：** 使用回溯算法生成所有有效的括号组合。在任意时刻，左括号数量不能超过n，右括号数量不能超过左括号数量。

**算法步骤：**

1. 递归构建括号序列，维护左右括号的计数
2. 如果左括号数量小于n，可以添加左括号
3. 如果右括号数量小于左括号数量，可以添加右括号
4. 当序列长度达到2n时，找到一个有效组合

**时间复杂度：** O(4^n / √n) - 第n个卡塔兰数的渐近值
**空间复杂度：** O(n) - 递归深度和路径存储空间

#### 代码实现

**Java版本：**

```java
public class GenerateParenthesis {
   public List<String> generateParenthesis(int n) {
      List<String> result = new ArrayList<>();
      StringBuilder path = new StringBuilder();
      backtrack(n, 0, 0, path, result);
      return result;
   }

   public void backtrack(int n, int leftCount, int rightCount, StringBuilder path, List<String> result) {
      if (path.length() == n * 2) {
         result.add(path.toString());
         return;
      }

      if (leftCount < n) {
         path.append('(');
         backtrack(n, leftCount + 1, rightCount, path, result);
         path.deleteCharAt(path.length() - 1);
      }

      if (leftCount > rightCount) {
         path.append(')');
         backtrack(n, leftCount, rightCount + 1, path, result);
         path.deleteCharAt(path.length() - 1);
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun generateParenthesis(n: Int): List<String> {
   val result = mutableListOf<String>()
   val path = StringBuilder()

   fun backtrack(leftCount: Int, rightCount: Int) {
      if (path.length == n * 2) {
         result.add(path.toString())
         return
      }

      if (leftCount < n) {
         path.append("(")
         backtrack(leftCount + 1, rightCount)
         path.deleteAt(path.lastIndex)
      }

      if (leftCount > rightCount) {
         path.append(")")
         backtrack(leftCount, rightCount + 1)
         path.deleteAt(path.lastIndex)
      }
   }
   backtrack(0, 0)
   return result
}
```

**括号生成的优势：**

- 通过约束条件有效剪枝，避免生成无效括号序列
- 递归逻辑简洁，易于理解验证
- 时间复杂度已达到理论最优

### [单词搜索](https://leetcode.cn/problems/word-search/)

**题目描述：**
给定一个 m x n 二维字符网格 board 和一个字符串单词 word，如果 word 存在于网格中，返回 true；否则，返回
false。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

**约束条件：**

- m == board.length
- n = board[i].length
- 1 ≤ m, n ≤ 6
- 1 ≤ word.length ≤ 15
- board 和 word 仅由大小写英文字母组成

#### 解题思路

**核心思想：** 使用回溯算法在二维网格中搜索单词。从每个可能的起始位置开始，沿着四个方向深度优先搜索，标记已访问的单元格避免重复使用。

**算法步骤：**

1. 遍历网格中的每个位置作为起始点
2. 使用DFS沿四个方向搜索匹配字符
3. 标记当前单元格为已访问，防止重复使用
4. 递归搜索下一个字符，回溯时恢复单元格状态
5. 如果匹配到单词末尾，返回成功

**时间复杂度：** O(m × n × 4^L) - m,n是网格大小，L是单词长度
**空间复杂度：** O(L) - 递归深度

#### 代码实现

**Java版本：**

```java
public class Exist {
   int[][] directions = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};

   public boolean exist(char[][] board, String word) {
      boolean[][] visited = new boolean[board.length][board[0].length];
      for (int row = 0; row < board.length; row++) {
         for (int col = 0; col < board[0].length; col++) {
            if (backtrack(board, word, row, col, 0, visited)) {
               return true;
            }
         }
      }
      return false;
   }

   public boolean backtrack(char[][] board, String word, int row, int col, int index, boolean[][] visited) {
      if (word.charAt(index) != board[row][col]) return false;
      if (index == word.length() - 1) return true;

      visited[row][col] = true;
      for (int[] direction : directions) {
         int newRow = row + direction[0];
         int newCol = col + direction[1];
         if (isValidPosition(board.length, board[0].length, newRow, newCol, visited)) {
            if (backtrack(board, word, newRow, newCol, index + 1, visited)) {
               return true;
            }
         }
      }
      visited[row][col] = false;
      return false;
   }

   public boolean isValidPosition(int maxRow, int maxCol, int row, int col, boolean[][] visited) {
      return row >= 0 && row < maxRow && col >= 0 && col < maxCol && !visited[row][col];
   }
}
```

**Kotlin版本：**

```kotlin
fun exist(board: Array<CharArray>, word: String): Boolean {
   val directions = arrayOf(intArrayOf(-1, 0), intArrayOf(1, 0), intArrayOf(0, -1), intArrayOf(0, 1))

   fun backtrack(row: Int, col: Int, index: Int): Boolean {
      if (board[row][col] != word[index]) return false
      if (index == word.lastIndex) return true

      val originalChar = board[row][col]
      board[row][col] = '0' // 标记为已访问

      for ((deltaRow, deltaCol) in directions) {
         val newRow = row + deltaRow
         val newCol = col + deltaCol

         if (newRow in board.indices && newCol in board[0].indices &&
            backtrack(newRow, newCol, index + 1)
         ) {
            return true
         }
      }
      board[row][col] = originalChar // 恢复原字符
      return false
   }

   for (row in board.indices) {
      for (col in board[0].indices) {
         if (backtrack(row, col, 0)) {
            return true
         }
      }
   }
   return false
}
```

**单词搜索的优势：**

- 通过回溯有效处理路径约束问题
- 避免额外空间存储访问状态（Kotlin版本）
- 四方向搜索覆盖所有可能路径

### [分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

**题目描述：**
给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。

**示例：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]

输入：s = "raceacar"
输出：[["r","a","c","e","a","c","a","r"],["r","a","ce","c","a","r"],["r","ace","ca","r"],["raceacar"]]

输入：s = "a"
输出：[["a"]]
```

**约束条件：**

- 1 ≤ s.length ≤ 16
- s 仅由小写英文字母组成

#### 解题思路

**核心思想：** 使用回溯算法枚举所有可能的分割方案。对于字符串的每个位置，尝试以该位置结束的所有可能子串，如果子串是回文串则继续递归分割剩余部分。

**算法步骤：**

1. 从字符串起始位置开始分割
2. 尝试每个可能的结束位置，检查子串是否为回文
3. 如果是回文串，将其加入当前路径，递归处理剩余字符串
4. 回溯时移除最后添加的子串，尝试其他分割方案
5. 当处理完整个字符串时，找到一个有效分割

**时间复杂度：** O(2^n × n) - 最多2^n种分割方案，每次检查回文需要O(n)
**空间复杂度：** O(n) - 递归深度和路径存储空间

#### 代码实现

**Java版本：**

```java
public class Partition {
   public List<List<String>> partition(String s) {
      List<List<String>> result = new ArrayList<>();
      ArrayDeque<String> path = new ArrayDeque<>();
      backtrack(s, 0, path, result);
      return result;
   }

   public void backtrack(String s, int startIndex, ArrayDeque<String> path, List<List<String>> result) {
      if (startIndex == s.length()) {
         result.add(new ArrayList<>(path));
         return;
      }

      for (int endIndex = startIndex; endIndex < s.length(); endIndex++) {
         if (isPalindrome(s, startIndex, endIndex)) {
            path.addLast(s.substring(startIndex, endIndex + 1));
            backtrack(s, endIndex + 1, path, result);
            path.removeLast();
         }
      }
   }

   private boolean isPalindrome(String s, int left, int right) {
      while (left < right) {
         if (s.charAt(left++) != s.charAt(right--)) return false;
      }
      return true;
   }
}
```

**Kotlin版本：**

```kotlin
fun partition(s: String): List<List<String>> {
   val result = mutableListOf<List<String>>()
   val path = mutableListOf<String>()

   fun isPalindrome(start: Int, end: Int): Boolean {
      var left = start
      var right = end
      while (left < right) {
         if (s[left++] != s[right--]) return false
      }
      return true
   }

   fun backtrack(startIndex: Int) {
      if (startIndex == s.length) {
         result.add(path.toList())
         return
      }

      for (endIndex in startIndex until s.length) {
         if (isPalindrome(startIndex, endIndex)) {
            path.add(s.substring(startIndex, endIndex + 1))
            backtrack(endIndex + 1)
            path.removeAt(path.lastIndex)
         }
      }
   }
   backtrack(0)
   return result
}
```

**回文分割的优势：**

- 逐步验证回文性质，避免无效分割
- 通过提前终止减少不必要的递归
- 空间复杂度优化，只存储当前分割路径

### [N 皇后](https://leetcode.cn/problems/n-queens/)

**题目描述：**
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n
的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n，返回所有不同的 n 皇后问题 的解决方案。

**示例：**

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：存在两个不同的 4 皇后问题 的解决方案

输入：n = 1
输出：[["Q"]]
```

**约束条件：**

- 1 ≤ n ≤ 9

#### 解题思路

**核心思想：** 使用回溯算法逐行放置皇后。对于每一行，尝试在每一列放置皇后，检查是否与之前放置的皇后冲突，如果不冲突则继续下一行。

**算法步骤：**

1. 逐行放置皇后，每行只能放置一个皇后
2. 对于当前行，尝试每一列的位置
3. 检查该位置是否与已放置的皇后冲突（列、对角线）
4. 如果不冲突，放置皇后并递归处理下一行
5. 回溯时移除皇后，尝试其他位置

**时间复杂度：** O(n!) - 第一行有n种选择，第二行最多n-2种选择...
**空间复杂度：** O(n) - 递归深度和棋盘存储空间

#### 代码实现

**Java版本：**

```java
public class SolveNQueens {
   public List<List<String>> solveNQueens(int n) {
      List<List<String>> result = new ArrayList<>();
      char[][] board = new char[n][n];

      for (int i = 0; i < n; i++) {
         for (int j = 0; j < n; j++) {
            board[i][j] = '.';
         }
      }

      boolean[] columns = new boolean[n];
      boolean[] mainDiagonal = new boolean[2 * n - 1];
      boolean[] antiDiagonal = new boolean[2 * n - 1];

      backtrack(board, 0, result, columns, mainDiagonal, antiDiagonal);
      return result;
   }

   private void backtrack(char[][] board, int row, List<List<String>> result,
                          boolean[] columns, boolean[] mainDiagonal, boolean[] antiDiagonal) {
      int n = board.length;
      if (row == n) {
         List<String> solution = new ArrayList<>();
         for (char[] rowChars : board) {
            solution.add(new String(rowChars));
         }
         result.add(solution);
         return;
      }

      for (int col = 0; col < n; col++) {
         int mainDiagIndex = row + col;
         int antiDiagIndex = row - col + n - 1;

         if (columns[col] || mainDiagonal[mainDiagIndex] || antiDiagonal[antiDiagIndex]) {
            continue;
         }

         board[row][col] = 'Q';
         columns[col] = true;
         mainDiagonal[mainDiagIndex] = true;
         antiDiagonal[antiDiagIndex] = true;

         backtrack(board, row + 1, result, columns, mainDiagonal, antiDiagonal);

         board[row][col] = '.';
         columns[col] = false;
         mainDiagonal[mainDiagIndex] = false;
         antiDiagonal[antiDiagIndex] = false;
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun solveNQueens(n: Int): List<List<String>> {
   val result = mutableListOf<List<String>>()
   val board = MutableList(n) { ".".repeat(n) }

   fun isValidPosition(row: Int, col: Int): Boolean {
      for (i in 0 until row) {
         if (board[i][col] == 'Q') return false
      }

      var r = row - 1
      var c = col + 1
      while (r >= 0 && c < n) {
         if (board[r][c] == 'Q') return false
         r--
         c++
      }

      r = row - 1
      c = col - 1
      while (r >= 0 && c >= 0) {
         if (board[r][c] == 'Q') return false
         r--
         c--
      }

      return true
   }

   fun backtrack(row: Int) {
      if (row == n) {
         result.add(board.toList())
         return
      }

      for (col in 0 until n) {
         if (!isValidPosition(row, col)) continue

         val newRow = StringBuilder(board[row]).apply {
            setCharAt(col, 'Q')
         }.toString()
         board[row] = newRow

         backtrack(row + 1)

         val resetRow = StringBuilder(board[row]).apply {
            setCharAt(col, '.')
         }.toString()
         board[row] = resetRow
      }
   }
   backtrack(0)
   return result
}
```

**N皇后问题的优势：**

- 通过预计算冲突状态显著提高效率（Java版本）
- 逐行放置避免行内冲突检查
- 经典回溯问题，展示了约束满足问题的解决思路

## 二分查找

### [搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

**题目描述：**
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

**示例：**

```
输入: nums = [1,3,5,6], target = 5
输出: 2

输入: nums = [1,3,5,6], target = 2
输出: 1

输入: nums = [1,3,5,6], target = 7
输出: 4
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^4
- -10^4 ≤ nums[i] ≤ 10^4
- nums 为无重复元素的升序排列数组
- -10^4 ≤ target ≤ 10^4

#### 解题思路

**核心思想：** 使用标准二分查找算法。当找不到目标值时，left指针最终会指向应该插入的位置。

**算法步骤：**

1. 初始化左右指针，left = 0, right = nums.length - 1
2. 在left <= right的条件下循环查找
3. 计算中点mid，比较nums[mid]与target
4. 如果相等则返回mid；如果nums[mid] < target则在右半部分查找；否则在左半部分查找
5. 循环结束后，left就是插入位置

**时间复杂度：** O(log n) - 标准二分查找
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class SearchInsert {
   public int searchInsert(int[] nums, int target) {
      int left = 0, right = nums.length - 1;
      while (left <= right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] == target) return mid;
         else if (nums[mid] < target) left = mid + 1;
         else right = mid - 1;
      }
      return left;
   }
}
```

**Kotlin版本：**

```kotlin
fun searchInsert(nums: IntArray, target: Int): Int {
   var left = 0
   var right = nums.size - 1

   while (left <= right) {
      val mid = left + (right - left) / 2

      when {
         nums[mid] == target -> return mid
         nums[mid] < target -> left = mid + 1
         else -> right = mid - 1
      }
   }
   return left
}
```

**二分查找解法的优势：**

- 时间复杂度O(log n)，比线性查找更高效
- 一次遍历即可找到插入位置，无需额外处理
- 代码简洁，逻辑清晰

### [搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

**题目描述：**
编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：

- 每行中的整数从左到右按升序排列
- 每行的第一个整数大于前一行的最后一个整数

**示例：**

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true

输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
输出：false
```

**约束条件：**

- m == matrix.length
- n == matrix[i].length
- 1 ≤ m, n ≤ 100
- -10^4 ≤ matrix[i][j] ≤ 10^4
- -10^4 ≤ target ≤ 10^4

#### 解题思路

**核心思想：** 从矩阵的右上角开始搜索，利用矩阵的有序性质，每次可以排除一行或一列。

**算法步骤：**

1. 从矩阵右上角开始，初始化row = 0, col = n - 1
2. 比较当前元素与目标值：
   - 如果相等，返回true
   - 如果当前元素大于目标值，向左移动（col--）
   - 如果当前元素小于目标值，向下移动（row++）
3. 重复直到找到目标或越界

**时间复杂度：** O(m + n) - 最多遍历m+n个元素
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class SearchMatrix {
   public boolean searchMatrix(int[][] matrix, int target) {
      int row = 0;
      int col = matrix[0].length - 1;

      while (row < matrix.length && col >= 0) {
         int current = matrix[row][col];
         if (current == target) {
            return true;
         } else if (current > target) {
            col--;
         } else {
            row++;
         }
      }
      return false;
   }
}
```

**Kotlin版本：**

```kotlin
fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {
   if (matrix.isEmpty() || matrix[0].isEmpty()) return false

   val rows = matrix.size
   val cols = matrix[0].size

   var row = 0
   var col = cols - 1

   while (row < rows && col >= 0) {
      when {
         matrix[row][col] == target -> return true
         matrix[row][col] > target -> col--
         else -> row++
      }
   }
   return false
}
```

**右上角搜索解法的优势：**

- 时间复杂度O(m + n)，比暴力搜索O(m * n)更高效
- 每次比较都能排除一行或一列，搜索范围快速缩小
- 算法简洁，易于理解和实现

### [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

**题目描述：**
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

**示例：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

输入：nums = [], target = 0
输出：[-1,-1]
```

**约束条件：**

- 0 ≤ nums.length ≤ 10^5
- -10^9 ≤ nums[i] ≤ 10^9
- nums 是一个非递减数组
- -10^9 ≤ target ≤ 10^9

#### 解题思路

**核心思想：** 使用两次二分查找，分别找到目标值的左边界和右边界。

**算法步骤：**

1. 第一次二分查找：找到目标值的左边界（第一个出现位置）
   - 当nums[mid] == target时，继续向左查找（right = mid - 1）
2. 第二次二分查找：找到目标值的右边界（最后一个出现位置）
   - 当nums[mid] == target时，继续向右查找（left = mid + 1）
3. 验证边界的有效性并返回结果

**时间复杂度：** O(log n) - 两次二分查找
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class SearchRange {
   public int[] searchRange(int[] nums, int target) {
      int leftBound = findLeftBound(nums, target);
      int rightBound = findRightBound(nums, target);
      return new int[]{leftBound, rightBound};
   }

   private int findLeftBound(int[] nums, int target) {
      int left = 0, right = nums.length - 1;
      while (left <= right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] == target) {
            right = mid - 1;
         } else if (nums[mid] < target) {
            left = mid + 1;
         } else {
            right = mid - 1;
         }
      }

      if (left < 0 || left >= nums.length || nums[left] != target) {
         return -1;
      }
      return left;
   }

   private int findRightBound(int[] nums, int target) {
      int left = 0, right = nums.length - 1;
      while (left <= right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] == target) {
            left = mid + 1;
         } else if (nums[mid] < target) {
            left = mid + 1;
         } else {
            right = mid - 1;
         }
      }

      if (right < 0 || right >= nums.length || nums[right] != target) {
         return -1;
      }
      return right;
   }
}
```

**Kotlin版本：**

```kotlin
fun searchRange(nums: IntArray, target: Int): IntArray {
   if (nums.isEmpty()) return intArrayOf(-1, -1)

   fun findLeftBound(): Int {
      var left = 0
      var right = nums.size - 1

      while (left <= right) {
         val mid = left + (right - left) / 2
         when {
            nums[mid] == target -> right = mid - 1
            nums[mid] < target -> left = mid + 1
            else -> right = mid - 1
         }
      }

      return if (left >= 0 && left < nums.size && nums[left] == target) left else -1
   }

   fun findRightBound(): Int {
      var left = 0
      var right = nums.size - 1

      while (left <= right) {
         val mid = left + (right - left) / 2
         when {
            nums[mid] == target -> left = mid + 1
            nums[mid] < target -> left = mid + 1
            else -> right = mid - 1
         }
      }

      return if (right >= 0 && right < nums.size && nums[right] == target) right else -1
   }

   return intArrayOf(findLeftBound(), findRightBound())
}
```

**双边界查找解法的优势：**

- 时间复杂度O(log n)，满足题目要求
- 通过两次二分查找准确定位边界
- 代码结构清晰，易于理解和维护

### [搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

**题目描述：**
整数数组 nums 按升序排列，数组中的值互不相同。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了旋转，使数组变为 [nums[k], nums[k+1], ...,
nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标从 0 开始计数）。

给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

**示例：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

输入：nums = [1], target = 0
输出：-1
```

**约束条件：**

- 1 ≤ nums.length ≤ 5000
- -10^4 ≤ nums[i] ≤ 10^4
- nums 中的每个值都独一无二
- 题目数据保证 nums 在预先未知的某个下标上进行了旋转
- -10^4 ≤ target ≤ 10^4

#### 解题思路

**核心思想：** 先找到旋转点（最小值位置），然后根据target与数组末尾元素的关系，决定在哪个有序部分进行二分查找。

**算法步骤：**

1. 使用二分查找找到旋转点（最小值的位置）
2. 比较target与数组最后一个元素的大小关系
3. 根据比较结果在左半部分或右半部分进行标准二分查找

**时间复杂度：** O(log n) - 两次二分查找
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class Search {
   public int search(int[] nums, int target) {
      int pivotIndex = findMinIndex(nums);

      if (pivotIndex == 0) {
         return binarySearch(nums, 0, nums.length - 1, target);
      }

      if (target > nums[nums.length - 1]) {
         return binarySearch(nums, 0, pivotIndex - 1, target);
      } else {
         return binarySearch(nums, pivotIndex, nums.length - 1, target);
      }
   }

   private int findMinIndex(int[] nums) {
      int left = 0, right = nums.length - 1;
      while (left < right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] > nums[right]) {
            left = mid + 1;
         } else {
            right = mid;
         }
      }
      return left;
   }

   private int binarySearch(int[] nums, int left, int right, int target) {
      while (left <= right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] == target) {
            return mid;
         } else if (nums[mid] < target) {
            left = mid + 1;
         } else {
            right = mid - 1;
         }
      }
      return -1;
   }
}
```

**Kotlin版本：**

```kotlin
fun search(nums: IntArray, target: Int): Int {
   if (nums.isEmpty()) return -1

   fun findMinIndex(): Int {
      var left = 0
      var right = nums.size - 1

      while (left < right) {
         val mid = left + (right - left) / 2
         when {
            nums[mid] > nums[right] -> left = mid + 1
            else -> right = mid
         }
      }
      return left
   }

   fun binarySearch(left: Int, right: Int): Int {
      var lo = left
      var hi = right

      while (lo <= hi) {
         val mid = lo + (hi - lo) / 2
         when {
            nums[mid] == target -> return mid
            nums[mid] > target -> hi = mid - 1
            else -> lo = mid + 1
         }
      }
      return -1
   }

   val pivotIndex = findMinIndex()

   return when {
      pivotIndex == 0 -> binarySearch(0, nums.size - 1)
      target > nums.last() -> binarySearch(0, pivotIndex - 1)
      else -> binarySearch(pivotIndex, nums.size - 1)
   }
}
```

**分治查找解法的优势：**

- 时间复杂度O(log n)，满足题目要求
- 通过找到旋转点将问题转化为标准二分查找
- 代码逻辑清晰，易于理解和调试

### [寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

**题目描述：**
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次旋转后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：

- 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
- 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值互不相同的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请找出并返回数组中的最小元素。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

**示例：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

**约束条件：**

- n == nums.length
- 1 ≤ n ≤ 5000
- -5000 ≤ nums[i] ≤ 5000
- nums 的所有整数互不相同
- nums 原来是一个升序排列的数组，并进行了 1 至 n 次旋转

#### 解题思路

**核心思想：** 使用二分查找，通过比较中间元素与最右元素的大小关系，来确定最小值的位置。

**算法步骤：**

1. 初始化左右指针，left = 0, right = nums.length - 1
2. 在left < right的条件下循环：
   - 计算中点mid
   - 如果nums[mid] > nums[right]，说明最小值在右侧，left = mid + 1
   - 否则最小值在左侧或当前位置，right = mid
3. 循环结束后，left指向最小值

**时间复杂度：** O(log n) - 二分查找
**空间复杂度：** O(1) - 只使用常数额外空间

#### 代码实现

**Java版本：**

```java
public class FindMin {
   public int findMin(int[] nums) {
      int left = 0, right = nums.length - 1;
      while (left < right) {
         int mid = left + (right - left) / 2;
         if (nums[mid] > nums[right]) {
            left = mid + 1;
         } else {
            right = mid;
         }
      }
      return nums[left];
   }
}
```

**Kotlin版本：**

```kotlin
fun findMin(nums: IntArray): Int {
   if (nums.isEmpty()) return -1
   if (nums.size == 1) return nums[0]

   var left = 0
   var right = nums.size - 1

   // 如果数组没有旋转（完全有序），直接返回第一个元素
   if (nums[left] < nums[right]) return nums[left]

   while (left < right) {
      val mid = left + (right - left) / 2

      when {
         // 如果中间值大于数组最后一个元素，最小值在右侧
         nums[mid] > nums[right] -> left = mid + 1
         // 否则，最小值在左侧
         else -> right = mid
      }
   }
   return nums[left]
}
```

**二分查找最小值解法的优势：**

- 时间复杂度O(log n)，满足题目要求
- 不需要完全遍历数组，效率高
- 代码简洁，逻辑清晰

### [寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

**题目描述：**
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。

算法的时间复杂度应该为 O(log (m+n)) 。

**示例：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**约束条件：**

- nums1.length == m
- nums2.length == n
- 0 ≤ m ≤ 1000
- 0 ≤ n ≤ 1000
- 1 ≤ m + n ≤ 2000
- -10^6 ≤ nums1[i], nums2[i] ≤ 10^6

#### 解题思路

**核心思想：** 先合并两个有序数组，然后根据合并后数组的长度计算中位数。

**算法步骤：**

1. 创建一个长度为 m+n 的数组用于存放合并结果
2. 使用双指针技术合并两个有序数组
3. 根据合并后数组的长度判断奇偶性：
   - 奇数长度：返回中间元素
   - 偶数长度：返回中间两个元素的平均值

**时间复杂度：** O(m + n) - 需要遍历两个数组
**空间复杂度：** O(m + n) - 需要额外空间存放合并结果

#### 代码实现

**Java版本：**

```java
public class FindMedianSortedArrays {
   public double findMedianSortedArrays(int[] nums1, int[] nums2) {
      int totalLength = nums1.length + nums2.length;
      int[] mergedArray = new int[totalLength];

      int index = 0, p1 = 0, p2 = 0;

      // 合并两个有序数组
      while (p1 < nums1.length && p2 < nums2.length) {
         if (nums1[p1] < nums2[p2]) {
            mergedArray[index++] = nums1[p1++];
         } else {
            mergedArray[index++] = nums2[p2++];
         }
      }

      // 处理剩余元素
      while (p1 < nums1.length) {
         mergedArray[index++] = nums1[p1++];
      }
      while (p2 < nums2.length) {
         mergedArray[index++] = nums2[p2++];
      }

      // 计算中位数
      if (totalLength % 2 == 0) {
         return (mergedArray[totalLength / 2] + mergedArray[totalLength / 2 - 1]) / 2.0;
      } else {
         return mergedArray[totalLength / 2];
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {
   val totalLength = nums1.size + nums2.size
   val mergedArray = IntArray(totalLength)

   var index = 0
   var p1 = 0
   var p2 = 0

   // 同时遍历两个数组，按顺序合并
   while (p1 < nums1.size && p2 < nums2.size) {
      mergedArray[index++] = if (nums1[p1] < nums2[p2]) nums1[p1++] else nums2[p2++]
   }

   // 处理剩余元素
   while (p1 < nums1.size) {
      mergedArray[index++] = nums1[p1++]
   }

   while (p2 < nums2.size) {
      mergedArray[index++] = nums2[p2++]
   }

   // 计算中位数
   return if (totalLength % 2 == 0) {
      // 偶数长度，取中间两个数的平均值
      (mergedArray[totalLength / 2] + mergedArray[totalLength / 2 - 1]) / 2.0
   } else {
      // 奇数长度，取中间的数
      mergedArray[totalLength / 2].toDouble()
   }
}
```

**合并数组解法的优势：**

- 算法简单直观，易于理解和实现
- 代码可读性强，逻辑清晰
- 适用于数据量不大的场景

## 栈

### [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

**题目描述：**
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例：**

```
输入：s = "()"
输出：true

输入：s = "()[]{}"
输出：true

输入：s = "(]"
输出：false

输入：s = "([)]"
输出：false

输入：s = "{[]}"
输出：true
```

**约束条件：**

- 1 ≤ s.length ≤ 10^4
- s 仅由括号 '()[]{}'构成

#### 解题思路

**核心思想：** 使用栈的后进先出特性来匹配括号。遇到左括号时入栈，遇到右括号时检查栈顶是否为对应的左括号。

**算法步骤：**

1. 遍历字符串中的每个字符
2. 遇到左括号 '('、'['、'{' 时，将其压入栈中
3. 遇到右括号时，检查栈是否为空或栈顶元素是否匹配
4. 如果不匹配或栈为空，返回false
5. 遍历结束后，检查栈是否为空

**时间复杂度：** O(n) - 需要遍历字符串一次
**空间复杂度：** O(n) - 最坏情况下所有字符都是左括号

#### 代码实现

**Java版本：**

```java
public class IsValid {
   public boolean isValid(String s) {
      ArrayDeque<Character> stack = new ArrayDeque<>();

      for (char c : s.toCharArray()) {
         if (c == '(' || c == '[' || c == '{') {
            stack.addLast(c);
         } else {
            if (stack.isEmpty()) return false;

            char top = stack.removeLast();
            if ((c == ')' && top != '(') ||
                    (c == ']' && top != '[') ||
                    (c == '}' && top != '{')) {
               return false;
            }
         }
      }

      return stack.isEmpty();
   }
}
```

**Kotlin版本：**

```kotlin
fun isValid(s: String): Boolean {
   val stack = ArrayDeque<Char>()

   for (c in s) {
      when (c) {
         '(', '[', '{' -> stack.addLast(c)
         else -> {
            if (stack.isEmpty()) return false

            val top = stack.removeLast()
            when (c) {
               ')' -> if (top != '(') return false
               ']' -> if (top != '[') return false
               '}' -> if (top != '{') return false
            }
         }
      }
   }

   return stack.isEmpty()
}
```

**栈解法的优势：**

- 时间复杂度O(n)，效率高
- 空间复杂度最优，只使用必要的栈空间
- 逻辑清晰，易于理解和实现

### [最小栈](https://leetcode.cn/problems/min-stack/)

**题目描述：**
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

- MinStack() 初始化堆栈对象。
- void push(int val) 将元素val推入堆栈。
- void pop() 删除堆栈顶部的元素。
- int top() 获取堆栈顶部的元素。
- int getMin() 检索堆栈中的最小元素。

**示例：**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // 返回 -3
minStack.pop();
minStack.top();    // 返回 0
minStack.getMin(); // 返回 -2
```

**约束条件：**

- -2^31 ≤ val ≤ 2^31 - 1
- pop、top 和 getMin 操作总是在非空栈上调用
- push、pop、top 和 getMin 最多被调用 3 * 10^4 次

#### 解题思路

**核心思想：** 使用辅助栈或在每个节点中存储当前最小值，确保在O(1)时间内获取最小元素。每个栈元素存储当前值和到目前为止的最小值。

**算法步骤：**

1. 定义栈节点，包含当前值和当前最小值
2. push时计算新的最小值并存储
3. pop时直接移除栈顶元素
4. top时返回栈顶元素的值
5. getMin时返回栈顶元素存储的最小值

**时间复杂度：** O(1) - 所有操作都是常数时间
**空间复杂度：** O(n) - 需要存储n个元素和对应的最小值

#### 代码实现

**Java版本：**

```java
class MinStack {
   private final ArrayDeque<Node> stack;

   static class Node {
      int val;
      int min;

      Node(int val, int min) {
         this.val = val;
         this.min = min;
      }
   }

   public MinStack() {
      stack = new ArrayDeque<>();
   }

   public void push(int val) {
      int currentMin = stack.isEmpty() ? val : Math.min(val, getMin());
      stack.addLast(new Node(val, currentMin));
   }

   public void pop() {
      stack.removeLast();
   }

   public int top() {
      return stack.peekLast().val;
   }

   public int getMin() {
      return stack.peekLast().min;
   }
}
```

**Kotlin版本：**

```kotlin
class MinStack {
   private val stack = ArrayDeque<Pair<Int, Int>>()

   fun push(value: Int) {
      val currentMin = if (stack.isEmpty()) value else minOf(getMin(), value)
      stack.addLast(Pair(value, currentMin))
   }

   fun pop() {
      stack.removeLast()
   }

   fun top(): Int = stack.last().first

   fun getMin(): Int = stack.last().second
}
```

**最小栈解法的优势：**

- 所有操作都是O(1)时间复杂度
- 空间效率高，每个元素只需额外存储一个最小值
- 实现简单，逻辑清晰

### [字符串解码](https://leetcode.cn/problems/decode-string/)

**题目描述：**
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

**示例：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"

输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"

输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"

输入：s = "2[2[y]pq4[2[jk]e1[f]]]ef"
输出："yypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef"
```

**约束条件：**

- 1 ≤ s.length ≤ 30
- s 由小写英文字母、数字和方括号 '[]' 组成
- s 保证是一个有效的输入
- s 中所有整数的取值范围为 [1, 300]

#### 解题思路

**核心思想：** 使用栈存储重复项信息，包括重复次数和要重复的内容。遇到'['时将重复次数入栈，遇到']'时弹出栈顶元素进行字符串重复操作。

**算法步骤：**

1. 初始化栈，放入一个重复次数为1的节点作为根节点
2. 遍历字符串，累积数字作为重复次数
3. 遇到'['时，创建新的重复项并入栈
4. 遇到']'时，弹出栈顶元素，重复其内容并加到新栈顶
5. 遇到字母时，直接加到当前栈顶的内容中

**时间复杂度：** O(n) - n为最终解码字符串的长度
**空间复杂度：** O(n) - 栈的深度和存储的字符串内容

#### 代码实现

**Java版本：**

```java
public class DecodeString {

   static class RepeatItem {
      StringBuilder content = new StringBuilder();
      int count;

      public RepeatItem(int count) {
         this.count = count;
      }

      @Override
      public String toString() {
         return content.toString().repeat(count);
      }
   }

   public String decodeString(String s) {
      ArrayDeque<RepeatItem> stack = new ArrayDeque<>();
      stack.add(new RepeatItem(1));
      StringBuilder number = new StringBuilder();

      for (char c : s.toCharArray()) {
         if (Character.isDigit(c)) {
            number.append(c);
         } else if (c == '[') {
            int count = Integer.parseInt(number.toString());
            number = new StringBuilder();
            stack.addLast(new RepeatItem(count));
         } else if (c == ']') {
            RepeatItem item = stack.removeLast();
            stack.peekLast().content.append(item.toString());
         } else {
            stack.peekLast().content.append(c);
         }
      }

      return stack.peekLast().toString();
   }
}
```

**Kotlin版本：**

```kotlin
class RepeatItem(val count: Int) {
   val content = StringBuilder()

   override fun toString(): String = content.toString().repeat(count)
}

fun decodeString(s: String): String {
   val stack = ArrayDeque<RepeatItem>().apply { add(RepeatItem(1)) }
   var number = StringBuilder()

   for (c in s) {
      when (c) {
         in '0'..'9' -> number.append(c)
         '[' -> {
            val count = number.toString().toInt()
            stack.add(RepeatItem(count))
            number = StringBuilder()
         }
         ']' -> {
            val item = stack.removeLast()
            stack.last().content.append(item.toString())
         }
         else -> stack.last().content.append(c)
      }
   }

   return stack.last().toString()
}
```

**字符串解码解法的优势：**

- 使用栈处理嵌套结构，思路清晰
- 时间复杂度与输出长度成正比，效率高
- 支持任意层次的嵌套编码

### [每日温度](https://leetcode.cn/problems/daily-temperatures/)

**题目描述：**
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i
天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

**示例：**

```
输入：temperatures = [73,74,75,71,69,72,76,73]
输出：[1,1,4,2,1,1,0,0]

输入：temperatures = [30,40,50,60]
输出：[1,1,1,0]

输入：temperatures = [30,60,90]
输出：[1,1,0]
```

**约束条件：**

- 1 ≤ temperatures.length ≤ 10^5
- 30 ≤ temperatures[i] ≤ 100

#### 解题思路

**核心思想：** 使用单调递减栈存储温度的索引。当遇到更高温度时，弹出栈中所有小于当前温度的索引，并计算等待天数。

**算法步骤：**

1. 初始化结果数组和单调递减栈（存储索引）
2. 遍历温度数组
3. 当栈不为空且当前温度高于栈顶索引对应的温度时，弹出栈顶
4. 计算等待天数（当前索引 - 弹出的索引）
5. 将当前索引入栈
6. 重复直到遍历完所有温度

**时间复杂度：** O(n) - 每个元素最多入栈和出栈一次
**空间复杂度：** O(n) - 栈的最大大小

#### 代码实现

**Java版本：**

```java
public class DailyTemperatures {
   public int[] dailyTemperatures(int[] temperatures) {
      ArrayDeque<Integer> stack = new ArrayDeque<>();
      int[] result = new int[temperatures.length];

      for (int day = 0; day < temperatures.length; day++) {
         while (!stack.isEmpty() && temperatures[stack.peekLast()] < temperatures[day]) {
            int prevDay = stack.removeLast();
            result[prevDay] = day - prevDay;
         }
         stack.addLast(day);
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun dailyTemperatures(temperatures: IntArray): IntArray {
   val stack = ArrayDeque<Int>()
   val result = IntArray(temperatures.size)

   temperatures.forEachIndexed { day, temperature ->
      while (stack.isNotEmpty() && temperatures[stack.last()] < temperature) {
         val prevDay = stack.removeLast()
         result[prevDay] = day - prevDay
      }
      stack.addLast(day)
   }

   return result
}
```

**每日温度解法的优势：**

- 时间复杂度O(n)，比暴力解法O(n²)效率高
- 使用单调栈巧妙解决"下一个更大元素"类型问题
- 空间复杂度优化，只需要一个辅助栈

### [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

**题目描述：**
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例：**

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10

输入：heights = [2,4]
输出：4

输入：heights = [1]
输出：1
```

**约束条件：**

- 1 ≤ heights.length ≤ 10^5
- 0 ≤ heights[i] ≤ 10^4

#### 解题思路

**核心思想：** 对于每个柱子，找到其左边和右边第一个比它矮的柱子位置，计算以该柱子为高度的矩形面积。使用单调递增栈分别求出左右边界。

**算法步骤：**

1. 使用单调递增栈求每个柱子左边第一个比它矮的位置
2. 使用单调递增栈求每个柱子右边第一个比它矮的位置
3. 对于每个柱子，计算矩形面积 = 高度 × (右边界 - 左边界 - 1)
4. 返回所有矩形面积的最大值

**时间复杂度：** O(n) - 每个元素最多入栈和出栈两次
**空间复杂度：** O(n) - 需要额外的数组存储边界信息

#### 代码实现

**Java版本：**

```java
public class LargestRectangleArea {
   public int largestRectangleArea(int[] heights) {
      if (heights.length == 0) return 0;

      int[] leftBoundary = new int[heights.length];
      int[] rightBoundary = new int[heights.length];
      ArrayDeque<Integer> stack = new ArrayDeque<>();
      int maxArea = 0;

      // 计算每个柱子左边第一个比它矮的柱子位置
      for (int i = 0; i < heights.length; i++) {
         while (!stack.isEmpty() && heights[stack.peekLast()] >= heights[i]) {
            stack.removeLast();
         }
         leftBoundary[i] = stack.isEmpty() ? -1 : stack.peekLast();
         stack.addLast(i);
      }

      stack.clear();

      // 计算每个柱子右边第一个比它矮的柱子位置
      for (int i = heights.length - 1; i >= 0; i--) {
         while (!stack.isEmpty() && heights[stack.peekLast()] >= heights[i]) {
            stack.removeLast();
         }
         rightBoundary[i] = stack.isEmpty() ? heights.length : stack.peekLast();
         stack.addLast(i);
      }

      // 计算每个柱子能够形成的最大矩形面积
      for (int i = 0; i < heights.length; i++) {
         int area = (rightBoundary[i] - leftBoundary[i] - 1) * heights[i];
         maxArea = Math.max(maxArea, area);
      }

      return maxArea;
   }
}
```

**Kotlin版本：**

```kotlin
fun largestRectangleArea(heights: IntArray): Int {
   if (heights.isEmpty()) return 0

   val leftBoundary = IntArray(heights.size)
   val rightBoundary = IntArray(heights.size)
   val stack = ArrayDeque<Int>()
   var maxArea = 0

   // 计算每个柱子左边第一个比它矮的柱子位置
   for (i in heights.indices) {
      while (stack.isNotEmpty() && heights[stack.last()] >= heights[i]) {
         stack.removeLast()
      }
      leftBoundary[i] = if (stack.isEmpty()) -1 else stack.last()
      stack.addLast(i)
   }

   stack.clear()

   // 计算每个柱子右边第一个比它矮的柱子位置
   for (i in heights.indices.reversed()) {
      while (stack.isNotEmpty() && heights[stack.last()] >= heights[i]) {
         stack.removeLast()
      }
      rightBoundary[i] = if (stack.isEmpty()) heights.size else stack.last()
      stack.addLast(i)
   }

   // 计算每个柱子能够形成的最大矩形面积
   heights.forEachIndexed { i, height ->
      val area = (rightBoundary[i] - leftBoundary[i] - 1) * height
      maxArea = maxOf(maxArea, area)
   }

   return maxArea
}
```

**柱状图最大矩形解法的优势：**

- 时间复杂度O(n)，比暴力解法O(n²)或O(n³)效率高
- 使用单调栈巧妙求解边界问题
- 思路清晰，将复杂问题分解为求左右边界的子问题

## 堆

### [数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

**题目描述：**
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例：**

```
输入: nums = [3,2,1,5,6,4], k = 2
输出: 5
解释: 排序后数组为 [6,5,4,3,2,1]，第2个最大元素是5

输入: nums = [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
解释: 排序后数组为 [6,5,5,4,3,3,2,2,1]，第4个最大元素是4
```

**约束条件：**

- 1 ≤ k ≤ nums.length ≤ 10^5
- -10^4 ≤ nums[i] ≤ 10^4

#### 解题思路

**核心思想：** 使用快速选择算法（QuickSelect），这是快速排序的变种，平均时间复杂度为O(n)。

**算法步骤：**

1. 随机选择一个基准值（pivot）
2. 将数组分为三部分：大于pivot、等于pivot、小于pivot
3. 根据各部分的大小判断第k大元素在哪一部分
4. 递归处理对应部分直到找到答案

**时间复杂度：** O(n) 平均情况，O(n²) 最坏情况
**空间复杂度：** O(n) 递归调用栈空间

#### 代码实现

**Java版本：**

```java
public class FindKthLargest {
   public int findKthLargest(int[] nums, int k) {
      return quickSelect(Arrays.asList(Arrays.stream(nums).boxed().toArray(Integer[]::new)), k);
   }

   private int quickSelect(List<Integer> nums, int k) {
      Random random = new Random();
      int pivot = nums.get(random.nextInt(nums.size()));

      List<Integer> larger = new ArrayList<>();
      List<Integer> equal = new ArrayList<>();
      List<Integer> smaller = new ArrayList<>();

      for (int num : nums) {
         if (num > pivot) {
            larger.add(num);
         } else if (num == pivot) {
            equal.add(num);
         } else {
            smaller.add(num);
         }
      }

      if (k <= larger.size()) {
         return quickSelect(larger, k);
      } else if (k <= larger.size() + equal.size()) {
         return pivot;
      } else {
         return quickSelect(smaller, k - larger.size() - equal.size());
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun findKthLargest(nums: IntArray, k: Int): Int {
   fun quickSelect(nums: List<Int>, k: Int): Int {
      val pivot = nums[Random.nextInt(nums.size)]

      val larger = mutableListOf<Int>()
      val equal = mutableListOf<Int>()
      val smaller = mutableListOf<Int>()

      for (num in nums) {
         when {
            num > pivot -> larger.add(num)
            num == pivot -> equal.add(num)
            else -> smaller.add(num)
         }
      }

      return when {
         k <= larger.size -> quickSelect(larger, k)
         k <= larger.size + equal.size -> pivot
         else -> quickSelect(smaller, k - larger.size - equal.size)
      }
   }

   return quickSelect(nums.toList(), k)
}
```

**快速选择算法的优势：**

- 平均时间复杂度O(n)，比完全排序更高效
- 原地操作，空间效率高
- 适用于只需要第k大元素而不需要完整排序的场景

### [前K个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

**题目描述：**
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

**示例：**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
解释: 元素1出现3次，元素2出现2次，元素3出现1次，前2个高频元素是1和2

输入: nums = [1], k = 1
输出: [1]
解释: 只有一个元素，频率最高的就是1
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^5
- k 的取值范围是 [1, 数组中不相同的元素的个数]
- 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的

#### 解题思路

**核心思想：** 使用哈希表统计频率，然后使用最小堆维护前k个高频元素。

**算法步骤：**

1. 使用哈希表统计每个元素出现的频率
2. 使用大小为k的最小堆，按频率排序
3. 遍历频率表，将元素加入堆中
4. 如果堆大小超过k，移除频率最小的元素
5. 最终堆中就是前k个高频元素

**时间复杂度：** O(n log k) - n是数组长度，k是要找的元素个数
**空间复杂度：** O(n + k) - 哈希表占用O(n)空间，堆占用O(k)空间

#### 代码实现

**Java版本：**

```java
public class TopKFrequent {
   public int[] topKFrequent(int[] nums, int k) {
      // 1. 统计频率
      Map<Integer, Integer> frequencyMap = new HashMap<>();
      for (int num : nums) {
         frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
      }

      // 2. 使用最小堆，按频率升序排列
      PriorityQueue<Map.Entry<Integer, Integer>> minHeap =
              new PriorityQueue<>(Map.Entry.comparingByValue());

      for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
         minHeap.offer(entry);
         if (minHeap.size() > k) {
            minHeap.poll(); // 移除频率最小的元素
         }
      }

      // 3. 提取结果
      int[] result = new int[k];
      for (int i = k - 1; i >= 0; i--) {
         result[i] = minHeap.poll().getKey();
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun topKFrequent(nums: IntArray, k: Int): IntArray {
   // 统计每个元素出现的频率
   val frequencyMap = mutableMapOf<Int, Int>()
   nums.forEach { num ->
      frequencyMap[num] = frequencyMap.getOrDefault(num, 0) + 1
   }

   // 如果k等于唯一元素的数量，直接返回所有元素
   if (k == frequencyMap.size) {
      return frequencyMap.keys.toIntArray()
   }

   // 使用最小堆，按照频率排序（频率小的在堆顶）
   val minHeap = PriorityQueue<Pair<Int, Int>>(compareBy { it.second })

   // 维护大小为k的最小堆
   for ((num, frequency) in frequencyMap) {
      minHeap.offer(Pair(num, frequency))
      if (minHeap.size > k) {
         minHeap.poll() // 移除频率最小的元素
      }
   }

   // 将堆中的元素转换为数组
   return IntArray(k) {
      minHeap.poll().first
   }
}
```

**最小堆解法的优势：**

- 时间复杂度O(n log k)，比完全排序更高效
- 空间复杂度O(n + k)，只需要维护k个元素的堆
- 适用于只需要前k个元素而不需要完整排序的场景

### [数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

**题目描述：**
中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

设计一个支持以下两个操作的数据结构：

- void addNum(int num) - 从数据流中添加一个整数到数据结构中。
- double findMedian() - 返回目前所有元素的中位数。

**示例：**

```
addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2
```

**约束条件：**

- 最多会对 addNum、findMedian 进行 50000 次调用
- -10^5 ≤ num ≤ 10^5

#### 解题思路

**核心思想：** 使用两个堆来维护数据流，大顶堆存储较小的一半数字，小顶堆存储较大的一半数字。

**算法步骤：**

1. 使用大顶堆存储较小的一半数字
2. 使用小顶堆存储较大的一半数字
3. 保持两个堆的大小平衡（大顶堆的大小等于或比小顶堆大1）
4. 中位数就是大顶堆的堆顶（奇数个元素）或两个堆顶的平均值（偶数个元素）

**时间复杂度：** addNum: O(log n), findMedian: O(1)
**空间复杂度：** O(n) - 存储所有元素

#### 代码实现

**Java版本：**

```java
class MedianFinder {
   // 大顶堆，存储较小的一半数字
   private PriorityQueue<Integer> maxHeap;
   // 小顶堆，存储较大的一半数字
   private PriorityQueue<Integer> minHeap;

   public MedianFinder() {
      maxHeap = new PriorityQueue<>((a, b) -> b - a); // 大顶堆
      minHeap = new PriorityQueue<>((a, b) -> a - b); // 小顶堆
   }

   public void addNum(int num) {
      // 如果两个堆大小相等，添加到大顶堆
      if (maxHeap.size() == minHeap.size()) {
         // 为了保持大顶堆中的元素都小于小顶堆中的元素
         // 先将num添加到小顶堆，然后将小顶堆的最小值移到大顶堆
         minHeap.offer(num);
         maxHeap.offer(minHeap.poll());
      } else {
         // 如果大顶堆比小顶堆大，添加到小顶堆
         // 同样，为了保持有序性，先添加到大顶堆，再将大顶堆的最大值移到小顶堆
         maxHeap.offer(num);
         minHeap.offer(maxHeap.poll());
      }
   }

   public double findMedian() {
      if (maxHeap.size() == minHeap.size()) {
         // 如果两个堆大小相等，中位数是两个堆顶元素的平均值
         return (maxHeap.peek() + minHeap.peek()) / 2.0;
      } else {
         // 如果大顶堆比小顶堆大，中位数是大顶堆的堆顶元素
         return maxHeap.peek();
      }
   }
}
```

**Kotlin版本：**

```kotlin
class MedianFinder {
   // 大顶堆，存储较小的一半数字
   private val maxHeap = PriorityQueue<Int> { a, b -> b - a }

   // 小顶堆，存储较大的一半数字
   private val minHeap = PriorityQueue<Int> { a, b -> a - b }

   fun addNum(num: Int) {
      // 如果两个堆大小相等，添加到大顶堆
      if (maxHeap.size == minHeap.size) {
         // 为了保持大顶堆中的元素都小于小顶堆中的元素
         // 先将num添加到小顶堆，然后将小顶堆的最小值移到大顶堆
         minHeap.offer(num)
         maxHeap.offer(minHeap.poll())
      } else {
         // 如果大顶堆比小顶堆大，添加到小顶堆
         // 同样，为了保持有序性，先添加到大顶堆，再将大顶堆的最大值移到小顶堆
         maxHeap.offer(num)
         minHeap.offer(maxHeap.poll())
      }
   }

   fun findMedian(): Double {
      return if (maxHeap.size == minHeap.size) {
         // 如果两个堆大小相等，中位数是两个堆顶元素的平均值
         (maxHeap.peek() + minHeap.peek()) / 2.0
      } else {
         // 如果大顶堆比小顶堆大，中位数是大顶堆的堆顶元素
         maxHeap.peek().toDouble()
      }
   }
}
```

**双堆解法的优势：**

- addNum操作时间复杂度O(log n)，findMedian操作时间复杂度O(1)
- 能够动态维护中位数，适用于数据流场景
- 空间效率高，只需要存储所有数据一次

## 贪心算法

### [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

**题目描述：**
给定一个数组 prices，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择某一天买入这只股票，并选择在未来的某一天卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0。

**示例：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。

输入：[7,6,4,3,1]
输出：0
解释：在这种情况下，没有交易完成，所以最大利润为 0。
```

**约束条件：**

- 1 ≤ prices.length ≤ 10^5
- 0 ≤ prices[i] ≤ 10^4

#### 解题思路

**核心思想：** 贪心算法，记录到目前为止遇到的最低价格，并计算当前价格与最低价格的差值，不断更新最大利润。

**算法步骤：**

1. 初始化最小价格为无穷大，最大利润为0
2. 遍历价格数组
3. 如果当前价格比最小价格小，更新最小价格
4. 否则计算当前利润（当前价格-最小价格），更新最大利润
5. 返回最大利润

**时间复杂度：** O(n) - 只需遍历一遍数组
**空间复杂度：** O(1) - 只使用常数级额外空间

#### 代码实现

**Java版本：**

```java
public class MaxProfit {
   public int maxProfit(int[] prices) {
      int maxProfit = 0;
      int minPrice = Integer.MAX_VALUE;

      for (int price : prices) {
         if (price < minPrice) {
            minPrice = price;
         } else if (price - minPrice > maxProfit) {
            maxProfit = price - minPrice;
         }
      }

      return maxProfit;
   }
}
```

**Kotlin版本：**

```kotlin
fun maxProfit(prices: IntArray): Int {
   var maxProfit = 0
   var minPrice = Int.MAX_VALUE

   for (price in prices) {
      if (price < minPrice) {
         minPrice = price
      } else if (price - minPrice > maxProfit) {
         maxProfit = price - minPrice
      }
   }

   return maxProfit
}
```

**贪心策略的优势：**

- 一次遍历即可得到最优解，时间复杂度最优
- 始终选择当前最优解（最低价格买入），保证全局最优
- 空间复杂度为常数级别，内存使用效率高

### [跳跃游戏](https://leetcode.cn/problems/jump-game/)

**题目描述：**
给定一个非负整数数组 nums，你最初位于数组的第一个下标。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**示例：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0，所以永远不可能到达最后一个下标。
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^4
- 0 ≤ nums[i] ≤ 10^5

#### 解题思路

**核心思想：** 贪心算法，维护当前能够到达的最远位置。如果在遍历过程中发现当前位置超出了能到达的最远位置，则无法到达终点。

**算法步骤：**

1. 初始化最远可达位置为0
2. 遍历数组的每个位置
3. 如果当前位置超出最远可达位置，返回false
4. 更新最远可达位置为当前位置+跳跃距离的最大值
5. 如果最远可达位置已经覆盖最后一个下标，返回true

**时间复杂度：** O(n) - 遍历数组一次
**空间复杂度：** O(1) - 只使用常数级额外空间

#### 代码实现

**Java版本：**

```java
public class CanJump {
   public boolean canJump(int[] nums) {
      if (nums.length == 1) return true;

      int maxReach = 0;

      for (int i = 0; i < nums.length; i++) {
         if (i > maxReach) return false;

         maxReach = Math.max(maxReach, i + nums[i]);

         if (maxReach >= nums.length - 1) return true;
      }

      return maxReach >= nums.length - 1;
   }
}
```

**Kotlin版本：**

```kotlin
fun canJump(nums: IntArray): Boolean {
   if (nums.size == 1) return true

   var maxReach = 0

   for (i in nums.indices) {
      if (i > maxReach) return false

      maxReach = maxOf(maxReach, i + nums[i])

      if (maxReach >= nums.lastIndex) return true
   }

   return maxReach >= nums.lastIndex
}
```

**贪心策略的优势：**

- 只需要关注能到达的最远位置，无需考虑具体跳跃路径
- 一次遍历即可判断，时间效率最优
- 提前终止判断，在确定能到达终点时立即返回

### [跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

**题目描述：**
给定一个非负整数数组 nums，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

**示例：**

```
输入：nums = [2,3,1,1,4]
输出：2
解释：跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

输入：nums = [2,3,0,1,4]
输出：2
```

**约束条件：**

- 1 ≤ nums.length ≤ 10^4
- 0 ≤ nums[i] ≤ 1000

#### 解题思路

**核心思想：** 贪心算法，使用边界跳跃的思想。维护当前跳跃的边界和下一跳能到达的最远位置。

**算法步骤：**

1. 维护当前边界curReach和最远可达位置maxReach
2. 遍历数组（除最后一个元素）
3. 更新最远可达位置
4. 当到达当前边界时，必须进行下一跳
5. 更新边界为最远可达位置，跳跃次数加1
6. 如果新边界已覆盖终点，提前返回

**时间复杂度：** O(n) - 遍历数组一次
**空间复杂度：** O(1) - 只使用常数级额外空间

#### 代码实现

**Java版本：**

```java
public class Jump {
   public int jump(int[] nums) {
      if (nums.length <= 1) return 0;

      int currentReach = 0;
      int maxReach = 0;
      int jumps = 0;

      for (int i = 0; i < nums.length - 1; i++) {
         maxReach = Math.max(maxReach, i + nums[i]);

         if (i == currentReach) {
            currentReach = maxReach;
            jumps++;

            if (currentReach >= nums.length - 1) {
               return jumps;
            }
         }
      }
      return jumps;
   }
}
```

**Kotlin版本：**

```kotlin
fun jump(nums: IntArray): Int {
   if (nums.size <= 1) return 0

   var currentReach = 0
   var maxReach = 0
   var jumps = 0

   for (i in 0 until nums.size - 1) {
      maxReach = maxOf(maxReach, i + nums[i])

      if (i == currentReach) {
         currentReach = maxReach
         jumps++

         if (currentReach >= nums.lastIndex) {
            return jumps
         }
      }
   }
   return jumps
}
```

**贪心策略的优势：**

- 每次跳跃都尽可能扩大可达范围，保证跳跃次数最少
- 边界触发机制确保在必要时才进行跳跃计数
- 一次遍历获得最优解，无需回溯或动态规划

### [划分字母区间](https://leetcode.cn/problems/partition-labels/)

**题目描述：**
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

返回一个表示每个字符串片段的长度的列表。

**示例：**

```
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
```

**约束条件：**

- 1 ≤ S.length ≤ 500
- S 仅由小写英文字母组成

#### 解题思路

**核心思想：** 贪心算法，先记录每个字符最后出现的位置，然后遍历字符串，维护当前片段的结束边界。

**算法步骤：**

1. 第一次遍历：记录每个字符最后出现的位置
2. 第二次遍历：维护当前片段的起始和结束位置
3. 更新片段结束位置为当前字符最后出现位置的最大值
4. 当遍历到片段结束位置时，记录片段长度
5. 更新下一个片段的起始位置

**时间复杂度：** O(n) - 两次遍历字符串
**空间复杂度：** O(1) - 只需要固定大小数组存储26个字母位置

#### 代码实现

**Java版本：**

```java
import java.util.*;

public class PartitionLabels {
   public List<Integer> partitionLabels(String s) {
      if (s.isEmpty()) return new ArrayList<>();

      int[] lastPositions = new int[26];

      for (int i = 0; i < s.length(); i++) {
         lastPositions[s.charAt(i) - 'a'] = i;
      }

      List<Integer> result = new ArrayList<>();
      int start = 0;
      int end = 0;

      for (int i = 0; i < s.length(); i++) {
         end = Math.max(end, lastPositions[s.charAt(i) - 'a']);

         if (i == end) {
            result.add(end - start + 1);
            start = i + 1;
         }
      }
      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun partitionLabels(s: String): List<Int> {
   if (s.isEmpty()) return emptyList()

   val lastPositions = IntArray(26)

   for (i in s.indices) {
      lastPositions[s[i] - 'a'] = i
   }

   val result = mutableListOf<Int>()
   var start = 0
   var end = 0

   for (i in s.indices) {
      end = maxOf(end, lastPositions[s[i] - 'a'])

      if (i == end) {
         result.add(end - start + 1)
         start = i + 1
      }
   }
   return result
}
```

**贪心策略的优势：**

- 通过预处理字符位置信息，避免重复搜索
- 每次确定片段边界时都是最优选择，保证片段数量最多
- 两次遍历即可完成，时间复杂度线性且高效

## 动态规划

### [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

**题目描述：**
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**约束条件：**

- 1 ≤ n ≤ 45

#### 解题思路

**核心思想：** 这是一个典型的动态规划问题，本质上是斐波那契数列的变种。要到达第n阶，可以从第(n-1)阶走1步，或从第(n-2)阶走2步。

**算法步骤：**

1. 建立状态转移方程：dp[i] = dp[i-1] + dp[i-2]
2. 确定边界条件：dp[1] = 1, dp[2] = 2
3. 优化空间复杂度，只保存前两个状态
4. 从第3阶开始计算到第n阶

**时间复杂度：** O(n) - 需要计算从3到n的每一阶
**空间复杂度：** O(1) - 只使用两个变量存储状态

#### 代码实现

**Java版本：**

```java
public class ClimbStairs {
   public int climbStairs(int n) {
      if (n <= 2) return n;

      // prev表示到达前两阶的方法数
      int prev = 1;
      // curr表示到达前一阶的方法数
      int curr = 2;

      // 从第3阶开始计算
      for (int i = 3; i <= n; i++) {
         // 计算当前阶的方法数
         int sum = prev + curr;
         // 更新状态：当前的前一阶变成下一轮的前两阶
         prev = curr;
         // 当前阶的方法数变成下一轮的前一阶
         curr = sum;
      }

      return curr;
   }
}
```

**Kotlin版本：**

```kotlin
fun climbStairs(n: Int): Int {
   if (n <= 2) return n

   // prev表示到达前两阶的方法数
   var prev = 1
   // curr表示到达前一阶的方法数
   var curr = 2

   // 从第3阶开始计算
   for (i in 3..n) {
      // 计算当前阶的方法数
      val sum = prev + curr
      // 更新状态：当前的前一阶变成下一轮的前两阶
      prev = curr
      // 当前阶的方法数变成下一轮的前一阶
      curr = sum
   }

   return curr
}
```

**动态规划解法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)，效率很高
- 状态转移方程简单清晰：f(n) = f(n-1) + f(n-2)
- 避免递归导致的重复计算和栈溢出问题

### [杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

**题目描述：**
给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例：**

```
输入：numRows = 5
输出：[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]

输入：numRows = 1
输出：[[1]]
```

**约束条件：**

- 1 ≤ numRows ≤ 30

#### 解题思路

**核心思想：** 杨辉三角每一行的首末元素都是1，中间元素等于上一行对应位置的两个元素之和。使用动态规划逐行构建。

**算法步骤：**

1. 创建结果列表，为每一行分配空间
2. 将所有位置初始化为1（处理边界情况）
3. 从第3行开始，计算中间元素：triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]
4. 返回完整的杨辉三角

**时间复杂度：** O(numRows²) - 需要填充所有位置
**空间复杂度：** O(numRows²) - 存储整个三角形

#### 代码实现

**Java版本：**

```java
public class Generate {
   public List<List<Integer>> generate(int numRows) {
      // 参数校验
      if (numRows <= 0) return new ArrayList<>();

      // 创建结果列表
      List<List<Integer>> result = new ArrayList<>();

      // 为每一行创建列表并初始化为1
      for (int i = 0; i < numRows; i++) {
         List<Integer> row = new ArrayList<>();
         for (int j = 0; j <= i; j++) {
            row.add(1);  // 初始值都为1
         }
         result.add(row);
      }

      // 从第3行(索引为2)开始填充中间元素
      for (int i = 2; i < numRows; i++) {
         for (int j = 1; j < i; j++) {
            // 当前元素等于上一行左上方和右上方元素之和
            result.get(i).set(j, result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));
         }
      }

      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun generate(numRows: Int): List<List<Int>> {
   // 参数校验
   if (numRows <= 0) return emptyList()

   // 创建结果列表，每行的长度为i+1，初始值都为1
   val result = List(numRows) { i -> MutableList(i + 1) { 1 } }

   // 从第3行(索引为2)开始填充中间元素
   for (i in 2 until numRows) {
      for (j in 1 until i) {
         // 当前元素等于上一行左上方和右上方元素之和
         result[i][j] = result[i - 1][j - 1] + result[i - 1][j]
      }
   }

   return result
}
```

**动态规划解法的优势：**

- 逐行构建，逻辑清晰易懂
- 边界处理简单：首末元素固定为1
- 一次遍历生成完整三角形，效率较高

### [打家劫舍](https://leetcode.cn/problems/house-robber/)

**题目描述：**
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之间能够偷窃到的最高金额。

**示例：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**约束条件：**

- 1 ≤ nums.length ≤ 100
- 0 ≤ nums[i] ≤ 400

#### 解题思路

**核心思想：** 对于每个房屋，小偷面临两个选择：偷或不偷。如果偷当前房屋，就不能偷前一间；如果不偷当前房屋，最大金额就是前一间房屋的最大金额。

**算法步骤：**

1. 定义状态：dp[i] 表示偷到第i间房屋时的最大金额
2. 状态转移方程：dp[i] = max(dp[i-1], dp[i-2] + nums[i])
3. 优化空间复杂度：只保存前两个状态
4. 遍历所有房屋，计算最大金额

**时间复杂度：** O(n) - 遍历一次数组
**空间复杂度：** O(1) - 只使用两个变量

#### 代码实现

**Java版本：**

```java
public class Rob {
   public int rob(int[] nums) {
      // 处理边界情况
      if (nums.length <= 2) {
         return Math.max(nums.length > 0 ? nums[0] : 0, nums.length > 1 ? nums[1] : 0);
      }

      // prev表示偷到前两个房屋为止的最大金额
      int prev = 0;
      // curr表示偷到前一个房屋为止的最大金额
      int curr = 0;

      for (int money : nums) {
         // 当前房屋的最大金额 = max(偷当前房屋 + 前两个房屋的最大金额, 不偷当前房屋)
         int maxMoney = Math.max(money + prev, curr);
         // 更新状态
         prev = curr;
         curr = maxMoney;
      }

      return curr;
   }
}
```

**Kotlin版本：**

```kotlin
fun rob(nums: IntArray): Int {
   // 处理边界情况
   if (nums.size <= 2) return maxOf(nums.getOrElse(0) { 0 }, nums.getOrElse(1) { 0 })

   // prev表示偷到前两个房屋为止的最大金额
   var prev = 0
   // curr表示偷到前一个房屋为止的最大金额
   var curr = 0

   for (money in nums) {
      // 当前房屋的最大金额 = max(偷当前房屋 + 前两个房屋的最大金额, 不偷当前房屋)
      val maxMoney = maxOf(money + prev, curr)
      // 更新状态
      prev = curr
      curr = maxMoney
   }

   return curr
}
```

**动态规划解法的优势：**

- 状态转移简单明了：选择偷或不偷的最优策略
- 空间优化到O(1)，效率极高
- 避免了递归解法的指数时间复杂度

### [完全平方数](https://leetcode.cn/problems/perfect-squares/)

**题目描述：**
给你一个整数 n ，返回和为 n 的完全平方数的最少数量。

完全平方数是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和
11 不是。

**示例：**

```
输入：n = 12
输出：3
解释：12 = 4 + 4 + 4

输入：n = 13
输出：2
解释：13 = 4 + 9
```

**约束条件：**

- 1 ≤ n ≤ 10^4

#### 解题思路

**核心思想：** 这是一个完全背包问题的变种。我们有无限个完全平方数可以选择，目标是用最少的完全平方数组成目标值n。

**算法步骤：**

1. 预处理所有小于等于n的完全平方数
2. 定义状态：dp[i] 表示组成数字i所需的最少完全平方数个数
3. 状态转移：对于每个数字，尝试减去每个完全平方数，取最小值
4. 边界条件：dp[0] = 0

**时间复杂度：** O(n * √n) - 对每个数字尝试所有完全平方数
**空间复杂度：** O(n) - 存储dp数组

#### 代码实现

**Java版本：**

```java
public class NumSquares {
   public int numSquares(int n) {
      // 收集所有小于等于n的完全平方数
      List<Integer> perfectSquares = new ArrayList<>();
      int sqrtValue = 1;
      while (sqrtValue * sqrtValue <= n) {
         perfectSquares.add(sqrtValue * sqrtValue);
         sqrtValue++;
      }

      // 创建dp数组，初始值设为最大整数
      int[] dp = new int[n + 1];
      Arrays.fill(dp, Integer.MAX_VALUE);
      dp[0] = 0; // 组成0需要0个完全平方数

      // 对于每个数字，尝试使用每个完全平方数来减少它
      for (int currentNum = 1; currentNum <= n; currentNum++) {
         for (int square : perfectSquares) {
            if (currentNum < square) break; // 完全平方数太大，无法使用

            // 使用当前完全平方数后，更新dp[currentNum]
            dp[currentNum] = Math.min(dp[currentNum], dp[currentNum - square] + 1);
         }
      }

      return dp[n];
   }
}
```

**Kotlin版本：**

```kotlin
fun numSquares(n: Int): Int {
   // 收集所有小于等于n的完全平方数
   val perfectSquares = mutableListOf<Int>()
   var sqrtValue = 1
   while (sqrtValue * sqrtValue <= n) {
      perfectSquares.add(sqrtValue * sqrtValue)
      sqrtValue++
   }

   // 创建dp数组，初始值设为最大整数
   val dp = IntArray(n + 1) { Int.MAX_VALUE }
   dp[0] = 0 // 组成0需要0个完全平方数

   // 对于每个数字，尝试使用每个完全平方数来减少它
   for (currentNum in 1..n) {
      for (square in perfectSquares) {
         if (currentNum < square) break // 完全平方数太大，无法使用

         // 使用当前完全平方数后，更新dp[currentNum]
         dp[currentNum] = minOf(dp[currentNum], dp[currentNum - square] + 1)
      }
   }

   return dp[n]
}
```

**动态规划解法的优势：**

- 将问题转化为完全背包问题，思路清晰
- 预处理完全平方数，提高效率
- 保证找到全局最优解

### [零钱兑换](https://leetcode.cn/problems/coin-change/)

**题目描述：**
给你一个整数数组 coins，表示不同面额的硬币；以及一个整数 amount，表示总金额。

计算并返回可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

**示例：**

```
输入：coins = [1,3,4], amount = 6
输出：2
解释：6 = 3 + 3

输入：coins = [2], amount = 3
输出：-1

输入：coins = [1], amount = 0
输出：0
```

**约束条件：**

- 1 ≤ coins.length ≤ 12
- 1 ≤ coins[i] ≤ 2^31 - 1
- 0 ≤ amount ≤ 10^4

#### 解题思路

**核心思想：** 这是经典的完全背包问题。对于每个金额，我们尝试使用每种硬币，选择使用硬币数量最少的方案。

**算法步骤：**

1. 定义状态：dp[i] 表示凑成金额i所需的最少硬币数
2. 初始化：dp[0] = 0，其他位置设为一个较大值
3. 状态转移：dp[amount] = min(dp[amount], dp[amount - coin] + 1)
4. 遍历所有金额和硬币组合

**时间复杂度：** O(amount * coins.length) - 双重循环
**空间复杂度：** O(amount) - 存储dp数组

#### 代码实现

**Java版本：**

```java
public class CoinChange {
   public int coinChange(int[] coins, int amount) {
      // 创建dp数组，初始化为一个较大的值
      int[] dp = new int[amount + 1];
      Arrays.fill(dp, Integer.MAX_VALUE / 2);
      dp[0] = 0; // 凑成金额0不需要任何硬币

      // 计算每个金额所需的最少硬币数
      for (int currentAmount = 1; currentAmount <= amount; currentAmount++) {
         for (int coin : coins) {
            // 只有当硬币面额小于等于当前金额时才能使用
            if (currentAmount < coin) continue;
            // 状态转移：使用当前硬币后，所需的最少硬币数
            dp[currentAmount] = Math.min(dp[currentAmount], dp[currentAmount - coin] + 1);
         }
      }

      // 如果dp[amount]仍为初始值，说明无法凑成总金额
      return dp[amount] == Integer.MAX_VALUE / 2 ? -1 : dp[amount];
   }
}
```

**Kotlin版本：**

```kotlin
fun coinChange(coins: IntArray, amount: Int): Int {
   // 创建dp数组，初始化为一个较大的值，避免整型溢出
   val dp = IntArray(amount + 1) { Int.MAX_VALUE / 2 }
   dp[0] = 0 // 凑成金额0不需要任何硬币

   // 计算每个金额所需的最少硬币数
   for (currentAmount in 1..amount) {
      for (coin in coins) {
         // 只有当硬币面额小于等于当前金额时才能使用
         if (currentAmount < coin) continue
         // 状态转移：使用当前硬币后，所需的最少硬币数
         dp[currentAmount] = minOf(dp[currentAmount], dp[currentAmount - coin] + 1)
      }
   }

   // 如果dp[amount]仍为初始值，说明无法凑成总金额
   return if (dp[amount] == Int.MAX_VALUE / 2) -1 else dp[amount]
}
```

**动态规划解法的优势：**

- 经典完全背包问题，状态转移清晰
- 时间复杂度优于暴力递归的指数级别
- 能够处理无解情况，返回-1

### [单词拆分](https://leetcode.cn/problems/word-break/)

**题目描述：**
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例：**

```
输入: s = "leetcode", wordDict = ["leet","code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

输入: s = "applepenapple", wordDict = ["apple","pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。

输入: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
输出: false
```

**约束条件：**

- 1 ≤ s.length ≤ 300
- 1 ≤ wordDict.length ≤ 1000
- 1 ≤ wordDict[i].length ≤ 20
- s 和 wordDict[i] 仅由小写英文字母组成
- wordDict 中的所有字符串互不相同

#### 解题思路

**核心思想：** 使用动态规划判断字符串是否可以被拆分。对于每个位置，检查从之前某个位置到当前位置的子串是否在字典中。

**算法步骤：**

1. 定义状态：dp[i] 表示字符串前i个字符是否可以被拆分
2. 优化：预先计算字典中最长单词长度，减少检查范围
3. 状态转移：dp[i] = dp[j] && wordDict.contains(s.substring(j, i))
4. 边界条件：dp[0] = true（空字符串可以被拆分）

**时间复杂度：** O(n * m) - n是字符串长度，m是最长单词长度
**空间复杂度：** O(n) - 存储dp数组

#### 代码实现

**Java版本：**

```java
public class WordBreak {
   public boolean wordBreak(String s, List<String> wordDict) {
      // 计算字典中最长单词的长度
      int maxWordLength = 0;
      for (String word : wordDict) {
         maxWordLength = Math.max(maxWordLength, word.length());
      }

      // 将字典转换为HashSet以提高查找效率
      Set<String> wordSet = new HashSet<>(wordDict);

      // dp[i]表示s的前i个字符是否可以被拆分
      boolean[] dp = new boolean[s.length() + 1];
      dp[0] = true; // 空字符串可以被拆分

      // 对于每个位置，检查是否可以从之前的某个位置加上字典中的单词得到
      for (int i = 1; i <= s.length(); i++) {
         // 只检查从i-maxWordLength到i-1的范围，优化时间复杂度
         int startPos = Math.max(i - maxWordLength, 0);
         for (int j = i - 1; j >= startPos; j--) {
            String word = s.substring(j, i);
            if (dp[j] && wordSet.contains(word)) {
               dp[i] = true;
               break; // 找到一种可行拆分即可停止
            }
         }
      }

      return dp[s.length()];
   }
}
```

**Kotlin版本：**

```kotlin
fun wordBreak(s: String, wordDict: List<String>): Boolean {
   // 计算字典中最长单词的长度
   val maxWordLength = wordDict.maxOfOrNull { it.length } ?: 0

   // 将字典转换为HashSet以提高查找效率
   val wordSet = wordDict.toHashSet()

   // dp[i]表示s的前i个字符是否可以被拆分
   val dp = BooleanArray(s.length + 1)
   dp[0] = true // 空字符串可以被拆分

   // 对于每个位置，检查是否可以从之前的某个位置加上字典中的单词得到
   for (i in 1..s.length) {
      // 只检查从i-maxWordLength到i-1的范围，优化时间复杂度
      val startPos = maxOf(i - maxWordLength, 0)
      for (j in (i - 1).downTo(startPos)) {
         val word = s.substring(j, i)
         if (dp[j] && wordSet.contains(word)) {
            dp[i] = true
            break // 找到一种可行拆分即可停止
         }
      }
   }

   return dp[s.length]
}
```

**动态规划解法的优势：**

- 避免了递归解法的重复计算和栈溢出
- 通过最长单词长度优化，减少不必要的字符串比较
- HashSet查找时间复杂度为O(1)，提高效率

### [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

**题目描述：**
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7]
的子序列。

**示例：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,18]，因此长度为 4 。

输入：nums = [0,1,0,3,2,3]
输出：4

输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**约束条件：**

- 1 ≤ nums.length ≤ 2500
- -10^4 ≤ nums[i] ≤ 10^4

#### 解题思路

**核心思想：** 定义dp[i]表示以nums[i]结尾的最长递增子序列长度。对于每个元素，检查之前所有较小的元素，取最长长度加1。

**算法步骤：**

1. 定义状态：dp[i] 表示以nums[i]结尾的最长递增子序列长度
2. 状态转移：dp[i] = max(dp[j] + 1) where j < i and nums[j] < nums[i]
3. 初始化：每个位置初始长度为1（单个元素的子序列）
4. 返回dp数组中的最大值

**时间复杂度：** O(n²) - 双重循环检查所有元素对
**空间复杂度：** O(n) - 存储dp数组

#### 代码实现

**Java版本：**

```java
public class LengthOfLIS {
   public int lengthOfLIS(int[] nums) {
      // dp[i]表示以nums[i]结尾的最长递增子序列的长度
      int[] dp = new int[nums.length];
      int maxLength = 0;

      for (int i = 0; i < nums.length; i++) {
         // 检查当前元素之前的所有元素
         for (int j = i - 1; j >= 0; j--) {
            // 如果找到一个更小的元素，可以将当前元素接在其后形成更长的递增子序列
            if (nums[j] < nums[i]) {
               dp[i] = Math.max(dp[i], dp[j]);
            }
         }
         // 将当前元素本身算入长度
         dp[i]++;

         // 更新全局最大长度
         maxLength = Math.max(maxLength, dp[i]);
      }

      return maxLength;
   }
}
```

**Kotlin版本：**

```kotlin
fun lengthOfLIS(nums: IntArray): Int {
   // dp[i]表示以nums[i]结尾的最长递增子序列的长度
   val dp = IntArray(nums.size) { 0 }
   var maxLength = 0

   for (i in nums.indices) {
      // 检查当前元素之前的所有元素
      for (j in i - 1 downTo 0) {
         // 如果找到一个更小的元素，可以将当前元素接在其后形成更长的递增子序列
         if (nums[j] < nums[i]) {
            dp[i] = maxOf(dp[i], dp[j])
         }
      }
      // 将当前元素本身算入长度
      dp[i]++

      // 更新全局最大长度
      maxLength = maxOf(maxLength, dp[i])
   }

   return maxLength
}
```

**动态规划解法的优势：**

- 经典LIS问题的基础解法，思路清晰易懂
- 状态转移方程简单：考虑所有可能的前驱元素
- 虽然时间复杂度为O(n²)，但对于中等规模数据足够高效

### [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

**题目描述：**
给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组是数组的连续子序列。

**示例：**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

**约束条件：**

- 1 ≤ nums.length ≤ 2 * 10^4
- -10 ≤ nums[i] ≤ 10
- nums[i] 的任何前缀或后缀的乘积都保证在 32-位 整数范围内

#### 解题思路

**核心思想：** 由于数组中可能有负数，负数乘以负数会变成正数，所以需要同时维护最大乘积和最小乘积。当前数为负数时，最小乘积可能变成最大乘积。

**算法步骤：**

1. 定义状态：dp[i] 存储以nums[i]结尾的子数组的(最小乘积, 最大乘积)
2. 状态转移：考虑三种情况：当前数乘以前面最小值、最大值，或单独作为子数组开始
3. 每次更新全局最大乘积
4. 处理0的特殊情况：0会重置乘积链

**时间复杂度：** O(n) - 遍历一次数组
**空间复杂度：** O(n) - 存储dp数组

#### 代码实现

**Java版本：**

```java
public class MaxProduct {
   public int maxProduct(int[] nums) {
      // dp[i]表示以nums[i]结尾的子数组的[最小乘积, 最大乘积]
      long[][] dp = new long[nums.length][2];
      long maxResult = nums[0];

      // 初始化第一个元素
      dp[0][0] = nums[0]; // 最小乘积
      dp[0][1] = nums[0]; // 最大乘积

      for (int i = 1; i < nums.length; i++) {
         long currentNum = nums[i];
         long prevMin = dp[i - 1][0];
         long prevMax = dp[i - 1][1];

         // 计算当前位置的最小乘积和最大乘积
         // 需要考虑三种情况：当前数乘以前面最小值、最大值，或者只取当前数
         long currentMin = Math.min(Math.min(currentNum * prevMin, currentNum * prevMax), currentNum);
         long currentMax = Math.max(Math.max(currentNum * prevMin, currentNum * prevMax), currentNum);

         dp[i][0] = currentMin;
         dp[i][1] = currentMax;

         // 更新全局最大乘积
         maxResult = Math.max(maxResult, currentMax);
      }

      return (int)maxResult;
   }
}
```

**Kotlin版本：**

```kotlin
fun maxProduct(nums: IntArray): Int {
   // dp[i]表示以nums[i]结尾的子数组的(最小乘积, 最大乘积)
   val dp = Array(nums.size) { 0L to 0L }
   var maxResult = nums[0].toLong()

   // 初始化第一个元素
   dp[0] = nums[0].toLong() to nums[0].toLong()

   for (i in 1 until nums.size) {
      val currentNum = nums[i].toLong()
      val (prevMin, prevMax) = dp[i - 1]

      // 计算当前位置的最小乘积和最大乘积
      // 需要考虑三种情况：当前数乘以前面最小值、最大值，或者只取当前数
      val currentMin = minOf(currentNum * prevMin, currentNum * prevMax, currentNum)
      val currentMax = maxOf(currentNum * prevMin, currentNum * prevMax, currentNum)

      dp[i] = currentMin to currentMax

      // 更新全局最大乘积
      maxResult = maxOf(maxResult, currentMax)
   }

   return maxResult.toInt()
}
```

**动态规划解法的优势：**

- 同时维护最大最小乘积，处理负数情况
- 一次遍历求解，时间复杂度O(n)
- 能正确处理数组中包含0的情况

### [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

**题目描述：**
给你一个只包含正整数的非空数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**约束条件：**

- 1 ≤ nums.length ≤ 200
- 1 ≤ nums[i] ≤ 100

#### 解题思路

**核心思想：** 这是一个0-1背包问题的变种。如果数组可以分割成两个和相等的子集，那么总和必须是偶数，且需要找到一个子集的和等于总和的一半。

**算法步骤：**

1. 计算数组总和，如果为奇数直接返回false
2. 目标和为总和的一半
3. 定义状态：dp[i][j] 表示使用前i个数字是否可以组成和为j
4. 状态转移：dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]] (if j >= nums[i])

**时间复杂度：** O(n * sum) - n是数组长度，sum是目标和
**空间复杂度：** O(n * sum) - 存储dp二维数组

#### 代码实现

**Java版本：**

```java
public class CanPartition {
   public boolean canPartition(int[] nums) {
      // 计算数组总和
      int totalSum = 0;
      for (int num : nums) {
         totalSum += num;
      }

      // 如果总和为奇数，无法分割成两个和相等的子集
      if (totalSum % 2 != 0) return false;

      // 目标和为总和的一半
      int targetSum = totalSum / 2;
      int numCount = nums.length;

      // dp[i][j]表示：使用前i个数字，是否可以组成和为j的子集
      boolean[][] dp = new boolean[numCount + 1][targetSum + 1];

      // 基础情况：空子集的和为0
      dp[0][0] = true;

      // 填充dp数组
      for (int i = 0; i < numCount; i++) {
         int currentNum = nums[i];
         for (int j = 0; j <= targetSum; j++) {
            // 不选择当前数字的情况
            dp[i + 1][j] = dp[i][j];

            // 选择当前数字的情况（如果j >= currentNum）
            if (j >= currentNum) {
               dp[i + 1][j] = dp[i + 1][j] || dp[i][j - currentNum];
            }
         }
      }

      // 返回最终结果：使用所有数字，是否可以组成和为targetSum的子集
      return dp[numCount][targetSum];
   }
}
```

**Kotlin版本：**

```kotlin
fun canPartition(nums: IntArray): Boolean {
   // 计算数组总和
   val totalSum = nums.sum()

   // 如果总和为奇数，无法分割成两个和相等的子集
   if (totalSum % 2 != 0) return false

   // 目标和为总和的一半
   val targetSum = totalSum / 2
   val numCount = nums.size

   // dp[i][j]表示：使用前i个数字，是否可以组成和为j的子集
   val dp = Array(numCount + 1) { BooleanArray(targetSum + 1) }

   // 基础情况：空子集的和为0
   dp[0][0] = true

   // 填充dp数组
   for (i in 0 until numCount) {
      val currentNum = nums[i]
      for (j in 0..targetSum) {
         // 不选择当前数字的情况
         dp[i + 1][j] = dp[i][j]

         // 选择当前数字的情况（如果j >= currentNum）
         if (j >= currentNum) {
            dp[i + 1][j] = dp[i + 1][j] || dp[i][j - currentNum]
         }
      }
   }

   // 返回最终结果：使用所有数字，是否可以组成和为targetSum的子集
   return dp[numCount][targetSum]
}
```

**动态规划解法的优势：**

- 将问题转化为经典的0-1背包问题
- 状态转移清晰：选择或不选择当前数字
- 可以进一步优化空间复杂度到O(sum)

### [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

**题目描述：**
给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"

输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"

输入：s = ""
输出：0
```

**约束条件：**

- 0 ≤ s.length ≤ 3 * 10^4
- s[i] 为 '(' 或 ')'

#### 解题思路

**核心思想：** 使用动态规划记录以每个位置结尾的最长有效括号长度。右括号可能与前面的左括号匹配，需要分情况讨论。

**算法步骤：**

1. 定义状态：dp[i] 表示以s[i]结尾的最长有效括号长度
2. 左括号：dp[i] = 0（左括号无法结尾）
3. 右括号分两种情况：
   - s[i-1] = '('：形如"()"，dp[i] = dp[i-2] + 2
   - s[i-1] = ')'：检查是否存在匹配的左括号
4. 返回dp数组中的最大值

**时间复杂度：** O(n) - 遍历一次字符串
**空间复杂度：** O(n) - 存储dp数组

#### 代码实现

**Java版本：**

```java
public class LongestValidParentheses {
   public int longestValidParentheses(String s) {
      // 空字符串直接返回0
      if (s.isEmpty()) return 0;

      // dp[i]表示以s[i]结尾的最长有效括号的长度
      int[] dp = new int[s.length()];
      int maxLength = 0;

      // 从索引1开始，因为单个字符不可能形成有效括号
      for (int i = 1; i < s.length(); i++) {
         if (s.charAt(i) == '(') {
            // 如果是左括号，则以它结尾的子串不可能是有效括号
            dp[i] = 0;
         } else {
            // 如果是右括号，则需要考虑两种情况
            if (s.charAt(i - 1) == '(') {
               // 情况1: 前一个字符是左括号，形如"...()"
               // dp[i-2]表示"..."部分的有效括号长度，加上新增的"()"长度2
               dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
            } else {
               // 情况2: 前一个字符是右括号，形如"...)))"
               // 检查是否存在匹配的左括号
               int matchingOpenPos = i - dp[i - 1] - 1;
               if (matchingOpenPos >= 0 && s.charAt(matchingOpenPos) == '(') {
                  // 计算新的有效括号长度
                  dp[i] = dp[i - 1] + 2 + (matchingOpenPos > 0 ? dp[matchingOpenPos - 1] : 0);
               }
            }
         }
         // 更新最长有效括号长度
         maxLength = Math.max(maxLength, dp[i]);
      }

      return maxLength;
   }
}
```

**Kotlin版本：**

```kotlin
fun longestValidParentheses(s: String): Int {
   // 空字符串直接返回0
   if (s.isEmpty()) return 0

   // dp[i]表示以s[i]结尾的最长有效括号的长度
   val dp = IntArray(s.length)
   var maxLength = 0

   // 从索引1开始，因为单个字符不可能形成有效括号
   for (i in 1 until s.length) {
      when (s[i]) {
         // 如果是左括号，则以它结尾的子串不可能是有效括号
         '(' -> dp[i] = 0

         // 如果是右括号，则需要考虑两种情况
         ')' -> {
            when (s[i - 1]) {
               // 情况1: 前一个字符是左括号，形如"...()"
               '(' -> {
                  // dp[i-2]表示"..."部分的有效括号长度，加上新增的"()"长度2
                  dp[i] = (if (i >= 2) dp[i - 2] else 0) + 2
               }
               // 情况2: 前一个字符是右括号，形如"...)))"
               ')' -> {
                  // 检查是否存在匹配的左括号
                  val matchingOpenPos = i - dp[i - 1] - 1
                  if (matchingOpenPos >= 0 && s[matchingOpenPos] == '(') {
                     // 计算新的有效括号长度
                     dp[i] = dp[i - 1] + 2 + (if (matchingOpenPos > 0) dp[matchingOpenPos - 1] else 0)
                  }
               }
            }
         }
      }
      // 更新最长有效括号长度
      maxLength = maxOf(maxLength, dp[i])
   }

   return maxLength
}
```

**动态规划解法的优势：**

- 一次遍历解决问题，时间复杂度O(n)
- 正确处理嵌套和连续的括号匹配情况
- 相比栈解法更直观，易于理解状态转移

## 多维动态规划

### [不同路径](https://leetcode.cn/problems/unique-paths/)

**题目描述：**
一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。

问总共有多少条不同的路径？

**示例：**

```
输入：m = 3, n = 7
输出：28

输入：m = 3, n = 2
输出：3
解释：从左上角到右下角一共有3条不同的路径：
1. 右 → 下 → 下
2. 下 → 右 → 下
3. 下 → 下 → 右
```

**约束条件：**

- 1 ≤ m, n ≤ 100

#### 解题思路

**核心思想：** 使用动态规划，dp[i][j]表示到达位置(i,j)的不同路径数。

**算法步骤：**

1. 创建 m×n 的 dp 数组
2. 初始化第一行和第一列为 1（只有一种到达方式）
3. 对于其他位置，路径数 = 上方路径数 + 左方路径数
4. 返回右下角的路径数

**时间复杂度：** O(m×n) - 遍历整个网格一次
**空间复杂度：** O(m×n) - dp 数组的空间

#### 代码实现

**Java版本：**

```java
public class UniquePaths {
   public int uniquePaths(int m, int n) {
      int[][] dp = new int[m][n];

      for (int i = 0; i < m; i++) {
         dp[i][0] = 1;
      }

      for (int j = 0; j < n; j++) {
         dp[0][j] = 1;
      }

      for (int i = 1; i < m; i++) {
         for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
         }
      }

      return dp[m - 1][n - 1];
   }
}
```

**Kotlin版本：**

```kotlin
fun uniquePaths(m: Int, n: Int): Int {
   val dp = Array(m) { IntArray(n) }

   for (i in 0 until m) {
      dp[i][0] = 1
   }

   for (j in 0 until n) {
      dp[0][j] = 1
   }

   for (i in 1 until m) {
      for (j in 1 until n) {
         dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
      }
   }

   return dp[m - 1][n - 1]
}
```

### [最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

**题目描述：**
给定一个包含非负整数的 m x n 网格 grid，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

**示例：**

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

输入：grid = [[1,2,3],[4,5,6]]
输出：12
解释：路径 1→2→3→6 的总和最小。
```

**约束条件：**

- m == grid.length
- n == grid[i].length
- 1 ≤ m, n ≤ 200
- 0 ≤ grid[i][j] ≤ 100

#### 解题思路

**核心思想：** 使用动态规划，dp[i][j] 表示到达位置(i,j)的最小路径和。

**算法步骤：**

1. 创建与原网格同大小的 dp 数组
2. 初始化起点位置和边界条件
3. 对于其他位置，最小路径和 = min(上方最小路径和, 左方最小路径和) + 当前位置值
4. 返回右下角的最小路径和

**时间复杂度：** O(m×n) - 遍历整个网格一次
**空间复杂度：** O(m×n) - dp 数组的空间

#### 代码实现

**Java版本：**

```java
public class MinPathSum {
   public int minPathSum(int[][] grid) {
      int m = grid.length;
      int n = grid[0].length;
      int[][] dp = new int[m][n];

      dp[0][0] = grid[0][0];

      for (int i = 1; i < m; i++) {
         dp[i][0] = dp[i - 1][0] + grid[i][0];
      }

      for (int j = 1; j < n; j++) {
         dp[0][j] = dp[0][j - 1] + grid[0][j];
      }

      for (int i = 1; i < m; i++) {
         for (int j = 1; j < n; j++) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
         }
      }

      return dp[m - 1][n - 1];
   }
}
```

**Kotlin版本：**

```kotlin
fun minPathSum(grid: Array<IntArray>): Int {
   val m = grid.size
   val n = grid[0].size
   val dp = Array(m) { IntArray(n) }

   dp[0][0] = grid[0][0]

   for (i in 1 until m) {
      dp[i][0] = dp[i - 1][0] + grid[i][0]
   }

   for (j in 1 until n) {
      dp[0][j] = dp[0][j - 1] + grid[0][j]
   }

   for (i in 1 until m) {
      for (j in 1 until n) {
         dp[i][j] = minOf(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
      }
   }

   return dp[m - 1][n - 1]
}
```

**动态规划解法的优势：**

- 时间复杂度 O(m×n)，比递归解法更高效
- 逻辑清晰，易于理解和实现
- 可以进一步优化空间复杂度至 O(min(m,n))

**动态规划解法的优势：**

- 时间复杂度 O(m×n)，比暴力搜索更高效
- 避免重复计算，适用于最优化问题
- 可以进一步优化空间复杂度至 O(min(m,n))

### [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

**题目描述：**
给你一个字符串 s，找到 s 中最长的回文子串。

**示例：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

输入：s = "cbbd"
输出："bb"
```

**约束条件：**

- 1 ≤ s.length ≤ 1000
- s 仅由数字和英文字母组成

#### 解题思路

**核心思想：** 使用动态规划，dp[i][j] 表示子串 s[i...j] 是否为回文串。

**算法步骤：**

1. 创建二维布尔数组记录子串是否为回文
2. 初始化单个字符和长度为2的子串
3. 按子串长度从3到n遍历，使用状态转移方程
4. 记录最长回文子串的位置和长度

**时间复杂度：** O(n²) - 遍历所有可能的子串
**空间复杂度：** O(n²) - 二维dp数组的空间

#### 代码实现

**Java版本：**

```java
public class LongestPalindrome {
   public String longestPalindrome(String s) {
      int n = s.length();
      if (n < 2) return s;

      boolean[][] dp = new boolean[n][n];
      int start = 0;
      int maxLen = 1;

      for (int i = 0; i < n; i++) {
         dp[i][i] = true;
      }

      for (int i = 0; i < n - 1; i++) {
         if (s.charAt(i) == s.charAt(i + 1)) {
            dp[i][i + 1] = true;
            start = i;
            maxLen = 2;
         }
      }

      for (int len = 3; len <= n; len++) {
         for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
               dp[i][j] = true;
               if (len > maxLen) {
                  start = i;
                  maxLen = len;
               }
            }
         }
      }

      return s.substring(start, start + maxLen);
   }
}
```

**Kotlin版本：**

```kotlin
fun longestPalindrome(s: String): String {
   val n = s.length
   if (n < 2) return s

   val dp = Array(n) { BooleanArray(n) }
   var start = 0
   var maxLen = 1

   for (i in 0 until n) {
      dp[i][i] = true
   }

   for (i in 0 until n - 1) {
      if (s[i] == s[i + 1]) {
         dp[i][i + 1] = true
         start = i
         maxLen = 2
      }
   }

   for (len in 3..n) {
      for (i in 0..n - len) {
         val j = i + len - 1
         if (s[i] == s[j] && dp[i + 1][j - 1]) {
            dp[i][j] = true
            if (len > maxLen) {
               start = i
               maxLen = len
            }
         }
      }
   }

   return s.substring(start, start + maxLen)
}
```

**动态规划解法的优势：**

- 时间复杂度 O(n²)，比暴力枚举更高效
- 空间换时间，避免重复计算子问题
- 逻辑清晰，状态转移方程易于理解

### [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

**题目描述：**
给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列，返回 0。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

**示例：**

```
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。

输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```

**约束条件：**

- 1 ≤ text1.length, text2.length ≤ 1000
- text1 和 text2 仅由小写英文字符组成

#### 解题思路

**核心思想：** 使用动态规划，dp[i][j] 表示 text1[0...i-1] 和 text2[0...j-1] 的最长公共子序列长度。

**算法步骤：**

1. 创建 (m+1)×(n+1) 的 dp 数组，初始化为 0
2. 遍历两个字符串，比较字符是否相同
3. 如果相同，dp[i][j] = dp[i-1][j-1] + 1
4. 如果不同，dp[i][j] = max(dp[i-1][j], dp[i][j-1])
5. 返回 dp[m][n]

**时间复杂度：** O(m×n) - m和n分别为两个字符串的长度
**空间复杂度：** O(m×n) - 二维dp数组的空间

#### 代码实现

**Java版本：**

```java
public class LongestCommonSubsequence {
   public int longestCommonSubsequence(String text1, String text2) {
      int m = text1.length();
      int n = text2.length();
      int[][] dp = new int[m + 1][n + 1];

      for (int i = 1; i <= m; i++) {
         for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
               dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
               dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
         }
      }

      return dp[m][n];
   }
}
```

**Kotlin版本：**

```kotlin
fun longestCommonSubsequence(text1: String, text2: String): Int {
   val m = text1.length
   val n = text2.length
   val dp = Array(m + 1) { IntArray(n + 1) }

   for (i in 1..m) {
      for (j in 1..n) {
         if (text1[i - 1] == text2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1
         } else {
            dp[i][j] = maxOf(dp[i - 1][j], dp[i][j - 1])
         }
      }
   }

   return dp[m][n]
}
```

**动态规划解法的优势：**

- 时间复杂度 O(m×n)，比暴力递归更高效
- 经典的二维DP问题，状态转移清晰
- 可以进一步优化空间复杂度至 O(min(m,n))

### [编辑距离](https://leetcode.cn/problems/edit-distance/)

**题目描述：**
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**约束条件：**

- 0 ≤ word1.length, word2.length ≤ 500
- word1 和 word2 由小写英文字母组成

#### 解题思路

**核心思想：** 使用动态规划，dp[i][j] 表示将 word1[0...i-1] 转换为 word2[0...j-1] 所需的最少操作数。

**算法步骤：**

1. 创建 (m+1)×(n+1) 的 dp 数组
2. 初始化边界条件：空字符串转换需要的操作数
3. 如果字符相同，不需要额外操作
4. 如果字符不同，取三种操作的最小值：插入、删除、替换
5. 返回 dp[m][n]

**时间复杂度：** O(m×n) - m和n分别为两个字符串的长度
**空间复杂度：** O(m×n) - 二维dp数组的空间

#### 代码实现

**Java版本：**

```java
public class MinDistance {
   public int minDistance(String word1, String word2) {
      int m = word1.length();
      int n = word2.length();
      int[][] dp = new int[m + 1][n + 1];

      for (int j = 0; j <= n; j++) {
         dp[0][j] = j;
      }

      for (int i = 0; i <= m; i++) {
         dp[i][0] = i;
      }

      for (int i = 1; i <= m; i++) {
         for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
               dp[i][j] = dp[i - 1][j - 1];
            } else {
               dp[i][j] = Math.min(
                       Math.min(
                               dp[i][j - 1] + 1,     // 插入操作
                               dp[i - 1][j] + 1      // 删除操作
                       ),
                       dp[i - 1][j - 1] + 1   // 替换操作
               );
            }
         }
      }

      return dp[m][n];
   }
}
```

**Kotlin版本：**

```kotlin
fun minDistance(word1: String, word2: String): Int {
   val m = word1.length
   val n = word2.length
   val dp = Array(m + 1) { IntArray(n + 1) }

   for (j in 0..n) {
      dp[0][j] = j
   }

   for (i in 0..m) {
      dp[i][0] = i
   }

   for (i in 1..m) {
      for (j in 1..n) {
         if (word1[i - 1] == word2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1]
         } else {
            dp[i][j] = minOf(
               dp[i][j - 1] + 1,     // 插入操作
               dp[i - 1][j] + 1,     // 删除操作
               dp[i - 1][j - 1] + 1  // 替换操作
            )
         }
      }
   }

   return dp[m][n]
}
```

**动态规划解法的优势：**

- 时间复杂度 O(m×n)，比递归解法更高效
- 经典的字符串编辑距离问题，状态转移清晰
- 广泛应用于文本处理和相似度计算

## 技巧

### [只出现一次的数字](https://leetcode.cn/problems/single-number/)

**题目描述：**
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**示例：**

```
输入：nums = [2,2,1]
输出：1

输入：nums = [4,1,2,1,2]
输出：4

输入：nums = [1]
输出：1
```

**约束条件：**

- 1 ≤ nums.length ≤ 3 * 10^4
- -3 * 10^4 ≤ nums[i] ≤ 3 * 10^4
- 除了某个元素只出现一次以外，其余每个元素均出现两次

#### 解题思路

**核心思想：** 使用异或运算的性质：相同数字异或为0，任何数与0异或都等于自己。

**算法步骤：**

1. 初始化结果为数组第一个元素
2. 遍历数组从第二个元素开始，依次与结果进行异或运算
3. 由于相同元素出现两次会相互抵消（异或为0），最终剩下的就是只出现一次的元素

**时间复杂度：** O(n) - 遍历数组一次
**空间复杂度：** O(1) - 只使用常数空间

#### 代码实现

**Java版本：**

```java
public class SingleNumber {
   public int singleNumber(int[] nums) {
      int result = nums[0];
      for (int i = 1; i < nums.length; i++) {
         result = result ^ nums[i];
      }
      return result;
   }
}
```

**Kotlin版本：**

```kotlin
fun singleNumber(nums: IntArray): Int {
   var result = nums[0]
   for (i in 1 until nums.size) {
      result = result xor nums[i]
   }
   return result
}
```

**异或运算解法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)，效率最优
- 利用异或运算的数学性质，代码简洁
- 适用于只有一个元素出现奇数次的场景

### [多数元素](https://leetcode.cn/problems/majority-element/)

**题目描述：**
给定一个大小为 n 的数组 nums，返回其中的多数元素。多数元素是指在数组中出现次数大于 ⌊n/2⌋ 的元素。

**示例：**

```
输入：nums = [3,2,3]
输出：3

输入：nums = [2,2,1,1,1,2,2]
输出：2
```

**约束条件：**

- n == nums.length
- 1 ≤ n ≤ 5 * 10^4
- -10^9 ≤ nums[i] ≤ 10^9
- 题目数据保证多数元素总是存在的

#### 解题思路

**核心思想：** 使用Boyer-Moore投票算法，通过"投票"机制找出出现次数超过一半的元素。

**算法步骤：**

1. 选择候选人(candidate)和计票器(count)
2. 遍历数组，如果计票器为0，选择当前元素作为候选人
3. 如果当前元素等于候选人，计票器+1；否则计票器-1
4. 最终候选人就是多数元素

**时间复杂度：** O(n) - 遍历数组一次
**空间复杂度：** O(1) - 只使用常数空间

#### 代码实现

**Java版本：**

```java
public class MajorityElement {
   public int majorityElement(int[] nums) {
      int candidate = 0;
      int count = 0;

      for (int num : nums) {
         if (count == 0) {
            candidate = num;
         }
         count += (num == candidate) ? 1 : -1;
      }

      return candidate;
   }
}
```

**Kotlin版本：**

```kotlin
fun majorityElement(nums: IntArray): Int {
   var candidate = 0
   var count = 0

   for (num in nums) {
      if (count == 0) {
         candidate = num
      }
      count += if (num == candidate) 1 else -1
   }

   return candidate
}
```

**Boyer-Moore算法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)，效率最优
- 不需要额外的存储空间来统计频次
- 算法巧妙利用了多数元素的数学性质

### [颜色分类](https://leetcode.cn/problems/sort-colors/)

**题目描述：**
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。

**示例：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]

输入：nums = [2,0,1]
输出：[0,1,2]
```

**约束条件：**

- n == nums.length
- 1 ≤ n ≤ 300
- nums[i] 为 0、1 或 2
- 你需要在原地排序，不能使用额外空间

#### 解题思路

**核心思想：** 使用三指针（荷兰国旗算法），将数组分为三个区域：已排序的0、待处理、已排序的2。

**算法步骤：**

1. 使用三个指针：left指向0区域的右边界，mid为当前处理元素，right指向2区域的左边界
2. 当nums[mid] == 0时，与left位置交换，left和mid都前进
3. 当nums[mid] == 1时，mid直接前进
4. 当nums[mid] == 2时，与right位置交换，right后退，mid不动（需要重新判断交换来的元素）

**时间复杂度：** O(n) - 遍历数组一次
**空间复杂度：** O(1) - 原地排序

#### 代码实现

**Java版本：**

```java
public class SortColors {
   public void sortColors(int[] nums) {
      int left = 0;
      int mid = 0;
      int right = nums.length - 1;

      while (mid <= right) {
         switch (nums[mid]) {
            case 0:
               swap(nums, left, mid);
               left++;
               mid++;
               break;
            case 1:
               mid++;
               break;
            case 2:
               swap(nums, mid, right);
               right--;
               break;
         }
      }
   }

   private void swap(int[] nums, int i, int j) {
      int temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
   }
}
```

**Kotlin版本：**

```kotlin
fun sortColors(nums: IntArray) {
   var left = 0
   var mid = 0
   var right = nums.lastIndex

   while (mid <= right) {
      when (nums[mid]) {
         0 -> {
            nums.swap(left, mid)
            left++
            mid++
         }
         1 -> {
            mid++
         }
         2 -> {
            nums.swap(mid, right)
            right--
         }
      }
   }
}

private fun IntArray.swap(i: Int, j: Int) {
   this[i] = this[j].also { this[j] = this[i] }
}
```

**三指针算法的优势：**

- 一次遍历完成排序，时间复杂度O(n)
- 原地排序，空间复杂度O(1)
- 经典的荷兰国旗问题解法，适用于三类元素分类

### [下一个排列](https://leetcode.cn/problems/next-permutation/)

**题目描述：**
整数数组的一个排列就是将其所有成员以序列或线性顺序排列。实现 next permutation，将数组重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数组重新排列成最小的排列（即升序排列）。

**示例：**

```
输入：nums = [1,2,3]
输出：[1,3,2]

输入：nums = [3,2,1]
输出：[1,2,3]

输入：nums = [1,1,5]
输出：[1,5,1]
```

**约束条件：**

- 1 ≤ nums.length ≤ 100
- 0 ≤ nums[i] ≤ 100
- 必须原地修改，只能使用常数的额外内存空间

#### 解题思路

**核心思想：** 找到第一个下降点，然后找到比它大的最小数字进行交换，最后将后面部分反转。

**算法步骤：**

1. 从右向左找到第一个下降点：nums[i] < nums[i+1]
2. 如果找到下降点，从右向左找到第一个比nums[i]大的数字nums[j]
3. 交换nums[i]和nums[j]
4. 将i+1到末尾的部分反转，得到下一个排列

**时间复杂度：** O(n) - 最多遍历数组三次
**空间复杂度：** O(1) - 原地修改

#### 代码实现

**Java版本：**

```java
public class NextPermutation {
   public void nextPermutation(int[] nums) {
      int n = nums.length;
      int i = n - 2;

      // 第一步：从右向左找到第一个下降点 nums[i] < nums[i+1]
      while (i >= 0 && nums[i] >= nums[i + 1]) {
         i--;
      }

      // 如果存在这样的 i，进行交换和反转
      if (i >= 0) {
         int j = n - 1;
         while (nums[j] <= nums[i]) {
            j--;
         }
         swap(nums, i, j);
      }

      // 反转 nums[i+1..n-1]
      reverse(nums, i + 1, n - 1);
   }

   private void swap(int[] nums, int i, int j) {
      int temp = nums[i];
      nums[i] = nums[j];
      nums[j] = temp;
   }

   private void reverse(int[] nums, int from, int to) {
      while (from < to) {
         swap(nums, from, to);
         from++;
         to--;
      }
   }
}
```

**Kotlin版本：**

```kotlin
fun nextPermutation(nums: IntArray) {
   val n = nums.size
   var i = n - 2

   // 第一步：从右向左找到第一个下降点 nums[i] < nums[i+1]
   while (i >= 0 && nums[i] >= nums[i + 1]) {
      i--
   }

   // 如果存在这样的 i，进行交换和反转
   if (i >= 0) {
      val j = (n - 1 downTo i + 1).first { nums[it] > nums[i] }
      nums.swap(i, j)
   }

   // 反转 nums[i+1..n-1]
   nums.reverse(i + 1, n - 1)
}

private fun IntArray.swap(i: Int, j: Int) {
   this[i] = this[j].also { this[j] = this[i] }
}

private fun IntArray.reverse(from: Int, to: Int) {
   var left = from
   var right = to
   while (left < right) {
      swap(left, right)
      left++
      right--
   }
}
```

**字典序算法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)，效率高
- 直接在原数组上操作，不需要额外空间
- 算法逻辑清晰，适用于生成排列的场景

### [寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

**题目描述：**
给定一个包含 n + 1 个整数的数组 nums，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有一个重复的整数，返回这个重复的数。

**示例：**

```
输入：nums = [1,3,4,2,2]
输出：2

输入：nums = [3,1,3,4,2]
输出：3

输入：nums = [3,3,3,3,3]
输出：3
```

**约束条件：**

- 1 ≤ n ≤ 10^5
- nums.length == n + 1
- 1 ≤ nums[i] ≤ n
- nums 中只有一个整数出现两次或多次，其余整数均只出现一次
- 不能修改数组，只能使用额外的 O(1) 空间

#### 解题思路

**核心思想：** 将数组看作链表，利用弗洛伊德判圈法（快慢指针）检测环，环的入口就是重复数字。

**算法步骤：**

1. 将数组索引和值构建成链表关系：index -> nums[index]
2. 使用快慢指针找到环中的相遇点
3. 将慢指针重新指向起点，快慢指针以相同速度前进
4. 再次相遇的位置就是环的入口，即重复数字

**时间复杂度：** O(n) - 遍历数组最多两次
**空间复杂度：** O(1) - 只使用常数空间

#### 代码实现

**Java版本：**

```java
public class FindDuplicate {
   public int findDuplicate(int[] nums) {
      // 使用弗洛伊德判圈法（快慢指针）查找环的入口
      int slow = nums[0];
      int fast = nums[0];

      // 第一步：快慢指针相遇，找到环中的一个相遇点
      do {
         slow = nums[slow];         // 慢指针每次走一步
         fast = nums[nums[fast]];   // 快指针每次走两步
      } while (slow != fast);

      // 第二步：将慢指针重新指向起点，快慢指针同步前进
      slow = nums[0];
      while (slow != fast) {
         slow = nums[slow];
         fast = nums[fast];
      }

      // 相遇点即为重复数字
      return slow;
   }
}
```

**Kotlin版本：**

```kotlin
fun findDuplicate(nums: IntArray): Int {
   // 使用弗洛伊德判圈法（快慢指针）查找环的入口
   var slow = nums[0]
   var fast = nums[0]

   // 第一步：快慢指针相遇，找到环中的一个相遇点
   do {
      slow = nums[slow]         // 慢指针每次走一步
      fast = nums[nums[fast]]   // 快指针每次走两步
   } while (slow != fast)

   // 第二步：将慢指针重新指向起点，快慢指针同步前进
   slow = nums[0]
   while (slow != fast) {
      slow = nums[slow]
      fast = nums[fast]
   }

   // 相遇点即为重复数字
   return slow
}
```

**弗洛伊德判圈法的优势：**

- 时间复杂度O(n)，空间复杂度O(1)，满足题目要求
- 不需要修改原数组，通过巧妙的链表构建解决问题
- 经典的环检测算法，适用于多种循环检测场景
